SCRIPT  /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/syntax/clojure.vim
Sourced 1 time
Total time:   0.008927
 Self time:   0.004569

count  total (s)   self (s)
                            " Vim indent file
                            " Language:           Clojure
                            " Maintainer:         Alex Vear <av@axvr.io>
                            " Former Maintainers: Sung Pae <self@sungpae.com>
                            "                     Meikel Brandmeyer <mb@kotka.de>
                            "                     Toralf Wittner <toralf.wittner@gmail.com>
                            " Contributors:       Joel Holdbrooks <cjholdbrooks@gmail.com> (Regexp support, bug fixes)
                            " URL:                https://github.com/clojure-vim/clojure.vim
                            " License:            Vim (see :h license)
                            " Last Change:        2021-02-13
                            
    1              0.000011 if exists("b:current_syntax")
                            	finish
    1              0.000002 endif
                            
    1              0.000011 let s:cpo_sav = &cpo
    1              0.000011 set cpo&vim
                            
    1              0.000008 if has("folding") && exists("g:clojure_fold") && g:clojure_fold > 0
                            	setlocal foldmethod=syntax
    1              0.000001 endif
                            
                            " -*- KEYWORDS -*-
                            " Generated from https://github.com/clojure-vim/clojure.vim/blob/f8594e7030cdfb0b7990ac92953c77a08a7220f0/clj/src/vim_clojure_static/generate.clj
                            " Clojure version 1.10.2
    1              0.001070 let s:clojure_syntax_keywords = {
                                \   'clojureBoolean': ["false","true"]
                                \ , 'clojureCond': ["case","clojure.core/case","clojure.core/cond","clojure.core/cond->","clojure.core/cond->>","clojure.core/condp","clojure.core/if-let","clojure.core/if-not","clojure.core/if-some","clojure.core/when","clojure.core/when-first","clojure.core/when-let","clojure.core/when-not","clojure.core/when-some","cond","cond->","cond->>","condp","if-let","if-not","if-some","when","when-first","when-let","when-not","when-some"]
                                \ , 'clojureConstant': ["nil"]
                                \ , 'clojureDefine': ["clojure.core/definline","clojure.core/definterface","clojure.core/defmacro","clojure.core/defmethod","clojure.core/defmulti","clojure.core/defn","clojure.core/defn-","clojure.core/defonce","clojure.core/defprotocol","clojure.core/defrecord","clojure.core/defstruct","clojure.core/deftype","definline","definterface","defmacro","defmethod","defmulti","defn","defn-","defonce","defprotocol","defrecord","defstruct","deftype"]
                                \ , 'clojureException': ["catch","finally","throw","try"]
                                \ , 'clojureFunc': ["*","*'","+","+'","-","-'","->ArrayChunk","->Eduction","->Vec","->VecNode","->VecSeq","-cache-protocol-fn","-reset-methods","/","<","<=","=","==",">",">=","PrintWriter-on","StackTraceElement->vec","Throwable->map","accessor","aclone","add-classpath","add-tap","add-watch","agent","agent-error","agent-errors","aget","alength","alias","all-ns","alter","alter-meta!","alter-var-root","ancestors","any?","apply","array-map","aset","aset-boolean","aset-byte","aset-char","aset-double","aset-float","aset-int","aset-long","aset-short","assoc","assoc!","assoc-in","associative?","atom","await","await-for","await1","bases","bean","bigdec","bigint","biginteger","bit-and","bit-and-not","bit-clear","bit-flip","bit-not","bit-or","bit-set","bit-shift-left","bit-shift-right","bit-test","bit-xor","boolean","boolean-array","boolean?","booleans","bound-fn*","bound?","bounded-count","butlast","byte","byte-array","bytes","bytes?","case-fallthrough-err-impl","cast","cat","char","char-array","char?","chars","ch
                                \ , 'clojureMacro': ["->","->>","..","amap","and","areduce","as->","assert","binding","bound-fn","clojure.core/->","clojure.core/->>","clojure.core/..","clojure.core/amap","clojure.core/and","clojure.core/areduce","clojure.core/as->","clojure.core/assert","clojure.core/binding","clojure.core/bound-fn","clojure.core/comment","clojure.core/declare","clojure.core/delay","clojure.core/dosync","clojure.core/doto","clojure.core/extend-protocol","clojure.core/extend-type","clojure.core/for","clojure.core/future","clojure.core/gen-class","clojure.core/gen-interface","clojure.core/import","clojure.core/io!","clojure.core/lazy-cat","clojure.core/lazy-seq","clojure.core/letfn","clojure.core/locking","clojure.core/memfn","clojure.core/ns","clojure.core/or","clojure.core/proxy","clojure.core/proxy-super","clojure.core/pvalues","clojure.core/refer-clojure","clojure.core/reify","clojure.core/some->","clojure.core/some->>","clojure.core/sync","clojure.core/time","clojure.core/vswap!","clojure.core/with-bindings","clojur
                                \ , 'clojureRepeat': ["clojure.core/doseq","clojure.core/dotimes","clojure.core/while","doseq","dotimes","while"]
                                \ , 'clojureSpecial': [".","clojure.core/fn","clojure.core/let","clojure.core/loop","def","do","fn","if","let","loop","monitor-enter","monitor-exit","new","quote","recur","set!","var"]
                                \ , 'clojureVariable': ["*1","*2","*3","*agent*","*allow-unresolved-vars*","*assert*","*clojure-version*","*command-line-args*","*compile-files*","*compile-path*","*compiler-options*","*data-readers*","*default-data-reader-fn*","*e","*err*","*file*","*flush-on-newline*","*fn-loader*","*in*","*math-context*","*ns*","*out*","*print-dup*","*print-length*","*print-level*","*print-meta*","*print-namespace-maps*","*print-readably*","*read-eval*","*reader-resolver*","*source-path*","*suppress-read*","*unchecked-math*","*use-context-classloader*","*verbose-defrecords*","*warn-on-reflection*","EMPTY-NODE","Inst","char-escape-string","char-name-string","clojure.core/*1","clojure.core/*2","clojure.core/*3","clojure.core/*agent*","clojure.core/*allow-unresolved-vars*","clojure.core/*assert*","clojure.core/*clojure-version*","clojure.core/*command-line-args*","clojure.core/*compile-files*","clojure.core/*compile-path*","clojure.core/*compiler-options*","clojure.core/*data-readers*","clojure.core/*default-data-reader-
                                \ }
                            
    1              0.000007 function! s:syntax_keyword(dict)
                            	for key in keys(a:dict)
                            		execute 'syntax keyword' key join(a:dict[key], ' ')
                            	endfor
                            endfunction
                            
    1              0.000007 if exists('b:clojure_syntax_without_core_keywords') && b:clojure_syntax_without_core_keywords
                            	" Only match language specials and primitives
                            	for s:key in ['clojureBoolean', 'clojureConstant', 'clojureException', 'clojureSpecial']
                            		execute 'syntax keyword' s:key join(s:clojure_syntax_keywords[s:key], ' ')
                            	endfor
    1              0.000003 else
    1   0.004389   0.000031 	call s:syntax_keyword(s:clojure_syntax_keywords)
    1              0.000003 endif
                            
    1              0.000007 if exists('g:clojure_syntax_keywords')
                            	call s:syntax_keyword(g:clojure_syntax_keywords)
    1              0.000001 endif
                            
    1              0.000004 if exists('b:clojure_syntax_keywords')
                            	call s:syntax_keyword(b:clojure_syntax_keywords)
    1              0.000001 endif
                            
    1              0.000003 unlet! s:key
    1              0.000006 delfunction s:syntax_keyword
                            
                            " Keywords are symbols:
                            "   static Pattern symbolPat = Pattern.compile("[:]?([\\D&&[^/]].*/)?([\\D&&[^/]][^/]*)");
                            " But they:
                            "   * Must not end in a : or /
                            "   * Must not have two adjacent colons except at the beginning
                            "   * Must not contain any reader metacharacters except for ' and #
    1              0.000028 syntax match clojureKeyword "\v<:{1,2}%([^ \n\r\t()\[\]{}";@^`~\\%/]+/)*[^ \n\r\t()\[\]{}";@^`~\\%/]+:@<!>"
                            
    1              0.000014 syntax match clojureStringEscape "\v\\%([\\btnfr"]|u\x{4}|[0-3]\o{2}|\o{1,2})" contained
                            
    1              0.000030 syntax region clojureString matchgroup=clojureStringDelimiter start=/"/ skip=/\\\\\|\\"/ end=/"/ contains=clojureStringEscape,@Spell
                            
    1              0.000008 syntax match clojureCharacter "\\."
    1              0.000010 syntax match clojureCharacter "\\o\%([0-3]\o\{2\}\|\o\{1,2\}\)"
    1              0.000008 syntax match clojureCharacter "\\u\x\{4\}"
    1              0.000008 syntax match clojureCharacter "\\space"
    1              0.000007 syntax match clojureCharacter "\\tab"
    1              0.000008 syntax match clojureCharacter "\\newline"
    1              0.000007 syntax match clojureCharacter "\\return"
    1              0.000007 syntax match clojureCharacter "\\backspace"
    1              0.000007 syntax match clojureCharacter "\\formfeed"
                            
    1              0.000017 syntax match clojureSymbol "\v%([a-zA-Z!$&*_+=|<.>?-]|[^\x00-\x7F])+%(:?%([a-zA-Z0-9!#$%&*_+=|'<.>/?-]|[^\x00-\x7F]))*[#:]@<!"
                            
    1              0.000005 let s:radix_chars = "0123456789abcdefghijklmnopqrstuvwxyz"
   36              0.000121 for s:radix in range(2, 36)
   35              0.000531 	execute 'syntax match clojureNumber "\v\c<[-+]?' . s:radix . 'r[' . strpart(s:radix_chars, 0, s:radix) . ']+>"'
   36              0.000075 endfor
    1              0.000004 unlet! s:radix_chars s:radix
                            
    1              0.000012 syntax match clojureNumber "\v<[-+]?%(0\o*|0x\x+|[1-9]\d*)N?>"
    1              0.000015 syntax match clojureNumber "\v<[-+]?%(0|[1-9]\d*|%(0|[1-9]\d*)\.\d*)%(M|[eE][-+]?\d+)?>"
    1              0.000012 syntax match clojureNumber "\v<[-+]?%(0|[1-9]\d*)/%(0|[1-9]\d*)>"
                            
    1              0.000006 syntax match clojureVarArg "&"
                            
    1              0.000010 syntax match clojureQuote "'"
    1              0.000007 syntax match clojureQuote "`"
    1              0.000007 syntax match clojureUnquote "\~"
    1              0.000007 syntax match clojureUnquote "\~@"
    1              0.000007 syntax match clojureMeta "\^"
    1              0.000007 syntax match clojureDeref "@"
    1              0.000012 syntax match clojureDispatch "\v#[\^'=<_]?"
                            
                            " Clojure permits no more than 20 anonymous params.
    1              0.000013 syntax match clojureAnonArg "%\(20\|1\d\|[1-9]\|&\)\?"
                            
    1              0.000019 syntax match  clojureRegexpEscape "\v\\%([\\tnrfae.()\[\]{}^$*?+]|c\u|0[0-3]?\o{1,2}|x%(\x{2}|\{\x{1,6}\})|u\x{4})" contained display
    1              0.000016 syntax region clojureRegexpQuoted start=/\\Q/ms=e+1 skip=/\\\\\|\\"/ end=/\\E/me=s-1 end=/"/me=s-1 contained
    1              0.000020 syntax region clojureRegexpQuote  start=/\\Q/       skip=/\\\\\|\\"/ end=/\\E/       end=/"/me=s-1 contains=clojureRegexpQuoted keepend contained
                            
                            " -*- CHARACTER PROPERTY CLASSES -*-
                            " Generated from https://github.com/clojure-vim/clojure.vim/blob/f8594e7030cdfb0b7990ac92953c77a08a7220f0/clj/src/vim_clojure_static/generate.clj
                            " Java version 15.0.2
    1              0.000021 syntax match clojureRegexpPosixCharClass "\v\\[pP]\{%(Cntrl|A%(l%(pha|num)|SCII)|Space|Graph|Upper|P%(rint|unct)|Blank|XDigit|Digit|Lower)\}" contained display
    1              0.000030 syntax match clojureRegexpJavaCharClass "\v\\[pP]\{java%(Whitespace|JavaIdentifier%(Part|Start)|SpaceChar|Mirrored|TitleCase|I%(SOControl|de%(ographic|ntifierIgnorable))|D%(efined|igit)|U%(pperCase|nicodeIdentifier%(Part|Start))|L%(etter%(OrDigit)?|owerCase)|Alphabetic)\}" contained display
    1              0.000065 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\cIs%(l%(owercase|etter)|hex%(digit|_digit)|w%(hite%(_space|space)|ord)|noncharacter%(_code_point|codepoint)|p%(rint|unctuation)|ideographic|graph|a%(l%(num|phabetic)|ssigned)|uppercase|join%(control|_control)|titlecase|blank|digit|control)\}" contained display
    1              0.000011 syntax match clojureRegexpUnicodeCharClass "\v\\[pP][NSCMZPL]" contained display
    1              0.000013 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{%(N[dlo]?|P[dcifeos]?|C[ncfos]?|M[nce]?|Z[lsp]?|S[mcko]?|L[muCDlto]?)\}" contained display
    1              0.000017 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{%(Is|gc\=|general_category\=)?%(N[dlo]?|P[dcifeos]?|C[ncfos]?|M[nce]?|Z[lsp]?|S[mcko]?|L[muCDlto]?)\}" contained display
    1              0.000207 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\c%(Is|sc\=|script\=)%(k%(its|h%(oj%(ki)?|m%(r|er)|itan_small_script|udawadi|ar%(oshthi)?)|a%(li|n%(a|nada)|takana%(_or_hiragana)?|yah_li|ithi)|nda|thi)|r%(ohg|un%(ic|r)|ejang|jng)|l%(epc%(ha)?|i%(mbu?|n%([ab]|ear_[ab])|su)|y%([dc]i%(an)?)|a%(t%(n|in)|na|oo?))|t%(elu%(gu)?|ha%(i|a%(na)?)|i%(finagh|rh%(uta)?|b%(t|etan))|fng|glg|a%(i_%(le|tham|viet)|g%(alog|b%(anwa)?)|vt|kri?|ng%(ut)?|l[ue]|m%(il|l)))|vaii?|y%(i%(ii)?|ezi%(di)?)|e%(thi%(opic)?|l%(ym%(aic)?|ba%(san)?)|gyp%(tian_hieroglyphs)?)|u%(gar%(itic)?|nknown)|h%(ung|ira%(gana)?|rkt|mn[gp]|a%(n%(i%(fi_rohingya)?|unoo|o|g%(ul)?)?|tr%(an)?)|luw|ebr%(ew)?)|g%(r%(e%(k|ek)|an%(tha)?)|lag%(olitic)?|eor%(gian)?|o%(n[mg]|th%(ic)?)|u%(j%(arati|r)|r%(u|mukhi)|njala_gondi))|m%(lym|a%(n%(d%(aic)?|i%(chaean)?)|saram_gondi|h%(ajani|j)|ka%(sar)?|rc%(hen)?|layalam)|o%(di|ng%(olian)?)|e%(r%(c|o%(itic_%(hieroglyphs|cursive))?)|etei_mayek|nd%(e_kikakui)?|d%(f|efaidrin))|roo?|y%(anmar|mr)|tei|iao|ult%(ani)?)|d%(upl%(oyan)?
    1              0.000862 syntax match clojureRegexpUnicodeCharClass "\v\\[pP]\{\c%(In|blk\=|block\=)%(zanabazar%([ _]square|square)|javanese|h%(a%(lfwidth%( and fullwidth forms|andfullwidthforms|_and_fullwidth_forms)|tran|n%(unoo|gul%(compatibilityjamo|syllables|jamo%(extended\-[ab])?|_%(syllables|jamo%(_extended_[ab])?|compatibility_jamo)| %(syllables|compatibility jamo|jamo%( extended\-[ab])?))|ifi%([_ ]rohingya|rohingya)))|i%(ragana|gh%( %(private use surrogates|surrogates)|_%(private_use_surrogates|surrogates)|surrogates|privateusesurrogates))|ebrew)|i%(pa%([ _]extensions|extensions)|n%(scriptional%(%([ _]pa%(rthian|hlavi))|pa%(rthian|hlavi))|dic%(siyaqnumbers|_siyaq_numbers| siyaq numbers))|deographic%(symbolsandpunctuation|_%(description_characters|symbols_and_punctuation)| %(description characters|symbols and punctuation)|descriptioncharacters)|mperial%(aramaic|[_ ]aramaic))|c%(o%(ntrol%(pictures|[ _]pictures)|ptic%(epactnumbers|_epact_numbers| epact numbers)?|m%(mon%(_indic_number_forms|indicnumberforms| indic number forms)|
                            
    1              0.000009 syntax match   clojureRegexpPredefinedCharClass "\v%(\\[dDsSwW]|\.)" contained display
    1              0.000018 syntax cluster clojureRegexpCharPropertyClasses contains=clojureRegexpPosixCharClass,clojureRegexpJavaCharClass,clojureRegexpUnicodeCharClass
    1              0.000019 syntax cluster clojureRegexpCharClasses         contains=clojureRegexpPredefinedCharClass,clojureRegexpCharClass,@clojureRegexpCharPropertyClasses
    1              0.000032 syntax region  clojureRegexpCharClass           start="\[" skip=/\\\\\|\\]/ end="]" contained contains=clojureRegexpPredefinedCharClass,@clojureRegexpCharPropertyClasses
    1              0.000006 syntax match   clojureRegexpBoundary            "\\[bBAGZz]" contained display
    1              0.000005 syntax match   clojureRegexpBoundary            "[$^]" contained display
    1              0.000007 syntax match   clojureRegexpQuantifier          "[?*+][?+]\=" contained display
    1              0.000009 syntax match   clojureRegexpQuantifier          "\v\{\d+%(,|,\d+)?}\??" contained display
    1              0.000005 syntax match   clojureRegexpOr                  "|" contained display
    1              0.000009 syntax match   clojureRegexpBackRef             "\v\\%([1-9]\d*|k\<[a-zA-z]+\>)" contained display
                            
                            " Mode modifiers, mode-modified spans, lookaround, regular and atomic
                            " grouping, and named-capturing.
    1              0.000008 syntax match clojureRegexpMod "\v\(@<=\?:" contained display
    1              0.000010 syntax match clojureRegexpMod "\v\(@<=\?[xdsmiuU]*-?[xdsmiuU]+:?" contained display
    1              0.000008 syntax match clojureRegexpMod "\v\(@<=\?%(\<?[=!]|\>)" contained display
    1              0.000008 syntax match clojureRegexpMod "\v\(@<=\?\<[a-zA-Z]+\>" contained display
                            
    1              0.000039 syntax region clojureRegexpGroup start="(" skip=/\\\\\|\\)/ end=")" matchgroup=clojureRegexpGroup contained contains=clojureRegexpMod,clojureRegexpQuantifier,clojureRegexpBoundary,clojureRegexpEscape,@clojureRegexpCharClasses
    1              0.000049 syntax region clojureRegexp start=/\#"/ skip=/\\\\\|\\"/ end=/"/ contains=@clojureRegexpCharClasses,clojureRegexpEscape,clojureRegexpQuote,clojureRegexpBoundary,clojureRegexpQuantifier,clojureRegexpOr,clojureRegexpBackRef,clojureRegexpGroup keepend
                            
    1              0.000009 syntax keyword clojureCommentTodo contained FIXME XXX TODO BUG NOTE HACK FIXME: XXX: TODO: BUG: NOTE: HACK:
                            
    1              0.000013 syntax match clojureComment ";.*$" contains=clojureCommentTodo,@Spell
    1              0.000010 syntax match clojureComment "#!.*$"
                            
                            " -*- TOP CLUSTER -*-
                            " Generated from https://github.com/clojure-vim/clojure.vim/blob/f8594e7030cdfb0b7990ac92953c77a08a7220f0/clj/src/vim_clojure_static/generate.clj
    1              0.000156 syntax cluster clojureTop contains=@Spell,clojureAnonArg,clojureBoolean,clojureCharacter,clojureComment,clojureCond,clojureConstant,clojureDefine,clojureDeref,clojureDispatch,clojureError,clojureException,clojureFunc,clojureKeyword,clojureMacro,clojureMap,clojureMeta,clojureNumber,clojureQuote,clojureRegexp,clojureRepeat,clojureSexp,clojureSpecial,clojureString,clojureSymbol,clojureUnquote,clojureVarArg,clojureVariable,clojureVector
                            
    1              0.000014 syntax region clojureSexp   matchgroup=clojureParen start="("  end=")" contains=@clojureTop fold
    1              0.000014 syntax region clojureVector matchgroup=clojureParen start="\[" end="]" contains=@clojureTop fold
    1              0.000014 syntax region clojureMap    matchgroup=clojureParen start="{"  end="}" contains=@clojureTop fold
                            
                            " Highlight superfluous closing parens, brackets and braces.
    1              0.000006 syntax match clojureError "]\|}\|)"
                            
    1              0.000002 syntax sync fromstart
                            
    1              0.000013 highlight default link clojureConstant                  Constant
    1              0.000008 highlight default link clojureBoolean                   Boolean
    1              0.000009 highlight default link clojureCharacter                 Character
    1              0.000008 highlight default link clojureKeyword                   Keyword
    1              0.000008 highlight default link clojureNumber                    Number
    1              0.000007 highlight default link clojureString                    String
    1              0.000008 highlight default link clojureStringDelimiter           String
    1              0.000008 highlight default link clojureStringEscape              Character
                            
    1              0.000008 highlight default link clojureRegexp                    Constant
    1              0.000008 highlight default link clojureRegexpEscape              Character
    1              0.000009 highlight default link clojureRegexpCharClass           SpecialChar
    1              0.000006 highlight default link clojureRegexpPosixCharClass      clojureRegexpCharClass
    1              0.000006 highlight default link clojureRegexpJavaCharClass       clojureRegexpCharClass
    1              0.000006 highlight default link clojureRegexpUnicodeCharClass    clojureRegexpCharClass
    1              0.000006 highlight default link clojureRegexpPredefinedCharClass clojureRegexpCharClass
    1              0.000007 highlight default link clojureRegexpBoundary            SpecialChar
    1              0.000009 highlight default link clojureRegexpQuantifier          SpecialChar
    1              0.000009 highlight default link clojureRegexpMod                 SpecialChar
    1              0.000007 highlight default link clojureRegexpOr                  SpecialChar
    1              0.000007 highlight default link clojureRegexpBackRef             SpecialChar
    1              0.000010 highlight default link clojureRegexpGroup               clojureRegexp
    1              0.000005 highlight default link clojureRegexpQuoted              clojureString
    1              0.000005 highlight default link clojureRegexpQuote               clojureRegexpBoundary
                            
    1              0.000009 highlight default link clojureVariable                  Identifier
    1              0.000008 highlight default link clojureCond                      Conditional
    1              0.000008 highlight default link clojureDefine                    Define
    1              0.000008 highlight default link clojureException                 Exception
    1              0.000008 highlight default link clojureFunc                      Function
    1              0.000008 highlight default link clojureMacro                     Macro
    1              0.000008 highlight default link clojureRepeat                    Repeat
                            
    1              0.000008 highlight default link clojureSpecial                   Special
    1              0.000007 highlight default link clojureVarArg                    Special
    1              0.000008 highlight default link clojureQuote                     SpecialChar
    1              0.000008 highlight default link clojureUnquote                   SpecialChar
    1              0.000008 highlight default link clojureMeta                      SpecialChar
    1              0.000008 highlight default link clojureDeref                     SpecialChar
    1              0.000008 highlight default link clojureAnonArg                   SpecialChar
    1              0.000008 highlight default link clojureDispatch                  SpecialChar
                            
    1              0.000007 highlight default link clojureComment                   Comment
    1              0.000007 highlight default link clojureCommentTodo               Todo
                            
    1              0.000007 highlight default link clojureError                     Error
                            
    1              0.000009 highlight default link clojureParen                     Delimiter
                            
    1              0.000005 let b:current_syntax = "clojure"
                            
    1              0.000017 let &cpo = s:cpo_sav
    1              0.000003 unlet! s:cpo_sav
                            
                            " vim:sts=8:sw=8:ts=8:noet

SCRIPT  /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/ftplugin/vim.vim
Sourced 1 time
Total time:   0.000379
 Self time:   0.000379

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Apr 11
                            
                            " Only do this when not done yet for this buffer
    1              0.000008 if exists("b:did_ftplugin")
                              finish
    1              0.000001 endif
                            
                            " Don't load another plugin for this buffer
    1              0.000003 let b:did_ftplugin = 1
                            
    1              0.000006 let s:cpo_save = &cpo
    1              0.000010 set cpo&vim
                            
    1              0.000005 if !exists('*VimFtpluginUndo')
                              func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
    1              0.000001 endif
                            
    1              0.000003 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    1              0.000012 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    1              0.000028 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    1              0.000004 setlocal keywordprg=:help
                            
                            " if "\n" .. getline(1, 10)->join("\n") =~# '\n\s*vim9\%[script]\>'
    1              0.000018 if "\n" .. join(getline(1, 10), "\n") =~# '\n\s*vim9\%[script]\>'
                              " Set 'comments' to format dashed lists in comments
                              setlocal com=sO:#\ -,mO:#\ \ ,eO:##,:#
                              " Comments starts with # in Vim9 script
                              setlocal commentstring=#%s
    1              0.000001 else
    1              0.000008   setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                              " Comments starts with a double quote in legacy script
    1              0.000004   setlocal commentstring=\"%s
    1              0.000001 endif
                            
                            
                            " Format comments to be up to 78 characters long
    1              0.000003 if &tw == 0
    1              0.000008   setlocal tw=78
    1              0.000001 endif
                            
                            " Prefer Vim help instead of manpages.
    1              0.000003 setlocal keywordprg=:help
                            
    1              0.000005 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    1              0.000003   let b:did_add_maps = 1
                            
                              " Move around functions.
    1              0.000016   nnoremap <silent><buffer> [[ m':call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000011   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "bW")<CR>
    1              0.000008   nnoremap <silent><buffer> ]] m':call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000010   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*\(fu\%[nction]\\|def\)\>', "W")<CR>
    1              0.000008   nnoremap <silent><buffer> [] m':call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000009   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "bW")<CR>
    1              0.000008   nnoremap <silent><buffer> ][ m':call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
    1              0.000009   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*end\(f\%[unction]\\|def\)\>', "W")<CR>
                            
                              " Move around comments
    1              0.000008   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000008   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    1              0.000008   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000009   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    1              0.000001 endif
                            
                            " Let the matchit plugin know what items can be matched.
    1              0.000004 if exists("loaded_matchit")
    1              0.000002   let b:match_ignorecase = 0
                              " "func" can also be used as a type:
                              "   var Ref: func
                              " or to list functions:
                              "   func name
                              " require a parenthesis following, then there can be an "endfunc".
    1              0.000025   let b:match_words =
                            	\ '\<\%(fu\%[nction]\|def\)!\=\s\+\S\+(:\%(\%(^\||\)\s*\)\@<=\<retu\%[rn]\>:\%(\%(^\||\)\s*\)\@<=\<\%(endf\%[unction]\|enddef\)\>,' .
                            	\ '\<\(wh\%[ile]\|for\)\>:\%(\%(^\||\)\s*\)\@<=\<brea\%[k]\>:\%(\%(^\||\)\s*\)\@<=\<con\%[tinue]\>:\%(\%(^\||\)\s*\)\@<=\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\%(\%(^\||\)\s*\)\@<=\<el\%[seif]\>:\%(\%(^\||\)\s*\)\@<=\<en\%[dif]\>,' .
                            	\ '{:},' .
                            	\ '\<try\>:\%(\%(^\||\)\s*\)\@<=\<cat\%[ch]\>:\%(\%(^\||\)\s*\)\@<=\<fina\%[lly]\>:\%(\%(^\||\)\s*\)\@<=\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ …
    1              0.000004   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    1              0.000001 endif
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/indent/vim.vim
Sourced 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2021 Apr 18
                            
                            " Only load this indent file when no other was loaded.
    1              0.000009 if exists("b:did_indent")
                              finish
    1              0.000001 endif
    1              0.000004 let b:did_indent = 1
                            
    1              0.000011 setlocal indentexpr=GetVimIndent()
    1              0.000006 setlocal indentkeys+==end,=},=else,=cat,=finall,=END,0\\,0=\"\\\ 
    1              0.000004 setlocal indentkeys-=0#
                            
    1              0.000003 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    1              0.000005 if exists("*GetVimIndent")
    1              0.000002   finish
                            endif
                            let s:keepcpo= &cpo
                            set cpo&vim
                            
                            function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
                            let s:lineContPat = '^\s*\(\\\|"\\ \)'
                            
                            function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " The previous line, ignoring line continuation
                              let prev_text_end = lnum > 0 ? getline(lnum) : ''
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ s:lineContPat
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                            
                              " the start of the previous line, skipping over line continuation
                              let prev_text = getline(lnum)
                              let found_cont = 0
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                            
                              " In heredoc indenting works completely differently.
                              if has('syntax_items') 
                                let syn_here = synIDattr(synID(v:lnum, 1, 1), "name")
                                if syn_here =~ 'vimLetHereDocStop'
                                  " End of heredoc: use indent of matching start line
                                  let lnum = v:lnum - 1
                                  while lnum > 0
                            	let attr = synIDattr(synID(lnum, 1, 1), "name")
                            	if attr != '' && attr !~ 'vimLetHereDoc'
                            	  return indent(lnum)
                            	endif
                            	let lnum -= 1
                                  endwhile
                                  return 0
                                endif
                                if syn_here =~ 'vimLetHereDoc'
                                  if synIDattr(synID(lnum, 1, 1), "name") !~ 'vimLetHereDoc'
                            	" First line in heredoc: increase indent
                            	return ind + shiftwidth()
                                  endif
                                  " Heredoc continues: no change in indent
                                  return ind
                                endif
                              endif
                            
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                let found_cont = 1
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                " A { may start a block or a dict.  Assume that when a } follows it's a
                                " terminated dict.
                                if prev_text !~ '^\s*au\%[tocmd]' && prev_text !~ '^\s*{.*}'
                                  let i = match(prev_text, '\(^\||\)\s*\(export\s\+\)\?\({\|\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\|finall\%[y]\|fu\%[nction]\|def\|el\%[seif]\)\>\)')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                              " For a line starting with "}" find the matching "{".  If it is at the start
                              " of the line align with it, probably end of a block.
                              " Use the mapped "%" from matchit to find the match, otherwise we may match
                              " a { inside a comment or string.
                              if cur_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe v:lnum
                                  silent! normal %
                                  if line('.') < v:lnum && getline('.') =~ '^\s*{'
                            	let ind = indent('.')
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Below a line starting with "}" find the matching "{".  If it is at the
                              " end of the line we must be below the end of a dictionary.
                              if prev_text =~ '^\s*}'
                                if maparg('%') != ''
                                  exe lnum
                                  silent! normal %
                                  if line('.') == lnum || getline('.') !~ '^\s*{'
                            	let ind = ind - shiftwidth()
                                  endif
                                else
                                  " todo: use searchpair() to find a match
                                endif
                              endif
                            
                              " Below a line starting with "]" we must be below the end of a list.
                              " Include a "}" and "},} in case a dictionary ends too.
                              if prev_text_end =~ '^\s*\(},\=\s*\)\=]'
                                let ind = ind - shiftwidth()
                              endif
                            
                              let ends_in_comment = has('syntax_items')
                            	\ && synIDattr(synID(lnum, len(getline(lnum)), 1), "name") =~ '\(Comment\|String\)$'
                            
                              " A line ending in "{" or "[" is most likely the start of a dict/list literal,
                              " indent the next line more.  Not for a continuation line or {{{.
                              if !ends_in_comment && prev_text_end =~ '\s[{[]\s*$' && !found_cont
                                let ind = ind + shiftwidth()
                              endif
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|finall\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/syntax/vim.vim
Sourced 1 time
Total time:   0.010369
 Self time:   0.008473

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    1              0.000010 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
    1              0.000010 let s:keepcpo= &cpo
    1              0.000011 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    1              0.000014 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    1              0.000010 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    1              0.000012 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    1              0.000008 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    1              0.000007 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    1              0.000021 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    1              0.000035 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    1              0.000011 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    1              0.000232 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    1              0.000013 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    1              0.000009 syn match   vimTermOption contained	"t_%1"
    1              0.000005 syn match   vimTermOption contained	"t_#2"
    1              0.000005 syn match   vimTermOption contained	"t_#4"
    1              0.000004 syn match   vimTermOption contained	"t_@7"
    1              0.000004 syn match   vimTermOption contained	"t_*7"
    1              0.000004 syn match   vimTermOption contained	"t_&8"
    1              0.000004 syn match   vimTermOption contained	"t_%i"
    1              0.000004 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    1              0.000005 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    1              0.000002 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    1              0.000022 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    1              0.000031 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question QuickFixLine Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    1              0.000021 syn match vimHLGroup contained	"Conceal"
    1              0.000006 syn keyword vimOnlyHLGroup contained	LineNrAbove LineNrBelow StatusLineTerm Terminal VisualNOS
    1              0.000006 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC
                            "}}}2
    1              0.000001 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands {{{2
    1              0.000010 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[afhlmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'h'
                              com! -nargs=* VimFoldh <args> fold
                             else
                              com! -nargs=* VimFoldh <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
    1              0.000001 else
    1              0.000008  com! -nargs=*	VimFolda	<args>
    1              0.000003  com! -nargs=*	VimFoldf	<args>
    1              0.000003  com! -nargs=*	VimFoldh	<args>
    1              0.000002  com! -nargs=*	VimFoldl	<args>
    1              0.000002  com! -nargs=*	VimFoldm	<args>
    1              0.000002  com! -nargs=*	VimFoldp	<args>
    1              0.000003  com! -nargs=*	VimFoldP	<args>
    1              0.000003  com! -nargs=*	VimFoldr	<args>
    1              0.000002  com! -nargs=*	VimFoldt	<args>
    1              0.000001 endif
                            
                            " commands not picked up by the generator (due to non-standard format) {{{2
    1              0.000006 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    1              0.000004 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
    1              0.000001 endif
    1              0.000002 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
    1              0.000001 endif
    1              0.000003 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
    1              0.000001 endif
                            
                            " Variable options {{{2
    1              0.000002 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
    1              0.000001 else
    1              0.000004  let s:vimsyn_maxlines= 60
    1              0.000001 endif
                            
                            " Numbers {{{2
                            " =======
    1              0.000033 syn match vimNumber	'\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=' skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000026 syn match vimNumber	'-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\='  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000024 syn match vimNumber	'\<0[xX]\x\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000026 syn match vimNumber	'\%(^\|\A\)\zs#\x\{6}'             	       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000026 syn match vimNumber	'\<0[zZ][a-zA-Z0-9.]\+'                    skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment
    1              0.000022 syn match vimNumber	'0[0-7]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment           
    1              0.000023 syn match vimNumber	'0b[01]\+'		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment,vim9Comment           
                            
                            " All vimCommands are contained by vimIsCommand. {{{2
    1              0.000065 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimEcho,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    1              0.000011 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    1              0.000007 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    1              0.000008 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000006 syn match vimVar	      	"\s\zs&\a\+\>"
    1              0.000007 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    1              0.000005 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    1              0.000019 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$""
    1              0.000014 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$""
    1              0.000028 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$""
    1              0.000018 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=starti\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    1              0.000015 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    1              0.000005 syn keyword vimBehaveModel contained	mswin	xterm
    1              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    1              0.000008  syn match   vimBehaveError contained	"[^ ]\+"
    1              0.000002 endif
                            
                            " Filetypes {{{2
                            " =========
    1              0.000052 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    1              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    1              0.000010  syn match   vimFTError  contained	"\I\i*"
    1              0.000002 endif
    1              0.000005 syn keyword vimFTCmd    contained	filet[ype]
    1              0.000005 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    1              0.000195 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimNotFunc,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vim9Comment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vim9Comment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    1              0.000009 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
    1              0.000002 else
    1              0.000019  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    1              0.000001 endif
    1              0.000009 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    1              0.000006 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    1              0.000007  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    1              0.000001 endif
    1              0.000005 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    1              0.000050 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue,vim9Comment
    1              0.000021 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    1              0.000016 syn match	vimOper	"\(\<is\|\<isnot\)[?#]\{0,2}\>"			skipwhite nextgroup=vimString,vimSpecFile
    1              0.000012 syn match	vimOper	"||\|&&\|[-+.!]"				skipwhite nextgroup=vimString,vimSpecFile
    1              0.000016 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=vimoperStar,@vimOperGroup
    1              0.000020 syn region	vimOperParen	matchgroup=vimSep		start="#\={" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    1              0.000009 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    1              0.000004  syn match	vimOperError	")"
    1              0.000001 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    1              0.000034 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    1              0.000141 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimEnvvar,vimExecute,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLetHereDoc,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSearch,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    1              0.000021 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    1              0.000006 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000002 else
    1              0.000017  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\|enddef\>\)"		contains=@vimFuncBodyList
    1              0.000001 endif
    1              0.000006 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    1              0.000021 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    1              0.000006 syn keyword	vimFuncKey   contained	fu[nction]
    1              0.000005 syn match	vimFuncBlank contained	"\s\+"
                            
    1              0.000004 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    1              0.000012 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000013 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000013 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000012 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000012 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    1              0.000013 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    1              0.000006 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    1              0.000277 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vim9Comment,vimCtrlChar,vimEscapeBrace,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    1              0.000007 syn keyword	vimUserCommand	contained	com[mand]
    1              0.000022 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList,vimComFilter
    1              0.000006 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    1              0.000012 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    1              0.000020 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    1              0.000016 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000015 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    1              0.000010 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    1              0.000010 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    1              0.000010 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    1              0.000010 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    1              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    1              0.000253  syn match	vimUserCmdError	contained	"\S\+\>"
    1              0.000002 endif
    1              0.000002 syn case ignore
    1              0.000015 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    1              0.000015 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    1              0.000012 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    1              0.000016 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    1              0.000002 syn case match
    1              0.000005 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    1              0.000014 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000013 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            " Vim9 comments - TODO: might be highlighted while they don't work
    1              0.000011 syn match	vim9Comment	excludenl +\s#[^{].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    1              0.000013 syn match	vim9Comment	+\<endif\s\+#[^{].*$+lc=5	contains=@vimCommentGroup,vimCommentString
    1              0.000011 syn match	vim9Comment	+\<else\s\+#[^{].*$+lc=4	contains=@vimCommentGroup,vimCommentString
                            " Vim9 comment inside expression
    1              0.000010 syn match	vim9Comment	+\s\zs#[^{].*$+ms=s+1	contains=@vimCommentGroup,vimCommentString
    1              0.000029 syn match	vim9Comment	+^\s*#[^{].*$+	contains=@vimCommentGroup,vimCommentString
    1              0.000009 syn match	vim9Comment	+^\s*#$+	contains=@vimCommentGroup,vimCommentString
                            
                            " Environment Variables: {{{2
                            " =====================
    1              0.000005 syn match	vimEnvvar	"\$\I\i*"
    1              0.000005 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    1              0.000016 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    1              0.000005 syn match	vimPatSepErr	contained	"\\)"
    1              0.000004 syn match	vimPatSep	contained	"\\|"
    1              0.000016 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\\]['"]"	contains=@vimStringGroup
    1              0.000013 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    1              0.000005 syn match	vimNotPatSep	contained	"\\\\"
    1              0.000019 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    1              0.000027 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    1              0.000012 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    1              0.000012 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    1              0.000012 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
                            "syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup  " see tst45.vim
    1              0.000011 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    1              0.000009 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    1              0.000033 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    1              0.000017 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    1              0.000007 syn cluster	vimSubstList	add=vimCollection
    1              0.000019 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
                            "syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    1              0.000014 syn match	vimSubst	"\%(^\|[^\\\"']\)\<s\%[ubstitute]\>[:#[:alpha:]\"']\@!"	nextgroup=vimSubstPat contained
    1              0.000040 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    1              0.000014 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    1              0.000009 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000008 syn match	vimSubst2       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    1              0.000022 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    1              0.000027 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    1              0.000013 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    1              0.000005 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    1              0.000016 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    1              0.000004 syn match	vimSubstSubstr  contained	"\\z\=\d"
    1              0.000004 syn match	vimSubstTwoBS   contained	"\\\\"
    1              0.000008 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    1              0.000005 syn match	vimSubstFlags   contained	"[&cegiIlnpr#]\+"
                            
                            " 'String': {{{2
    1              0.000005 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    1              0.000016 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000014 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000021 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000024 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000024 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimFilter,vimMarkNumber,vimSubst
    1              0.000018 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst2
    1              0.000007 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
    1              0.000021 syn match	vimRange	"[`'][a-zA-Z0-9],[`'][a-zA-Z0-9]"	contains=vimMark	skipwhite nextgroup=vimFilter
                            
    1              0.000013 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    1              0.000007 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    1              0.000006 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    1              0.000005 syn match	vimRegister	'@"'
    1              0.000006 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    1              0.000008 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    1              0.000010 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    1              0.000014 syn match	vimFilter 		"^!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000012 syn match	vimFilter    contained	"!!\=[^"]\{-}\(|\|\ze\"\|$\)"	contains=vimOper,vimSpecFile
    1              0.000012 syn match	vimComFilter contained	"|!!\=[^"]\{-}\(|\|\ze\"\|$\)"      contains=vimOper,vimSpecFile
                            
                            " Complex Repeats: (:h complex-repeat) {{{2
    1              0.000006 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    1              0.000007 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    1              0.000057 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vim9Comment,vimSetString,vimSetMod
    1              0.000070 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    1              0.000017 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    1              0.000007 syn match	vimSetSep	contained	"[,:]"
    1              0.000006 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let: {{{2
                            " ===
    1              0.000018 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar,vimLetHereDoc
    1              0.000033 VimFoldh syn region vimLetHereDoc	matchgroup=vimLetHereDocStart start='=<<\s\+\%(trim\>\)\=\s*\z(\L\S*\)'	matchgroup=vimLetHereDocStop end='^\s*\z1\s*$'	contains=vimComment,vim9Comment
                            
                            " Abbreviations: {{{2
                            " =============
    1              0.000024 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd: {{{2
                            " =======
    1              0.000017 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    1              0.000008 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    1              0.000008 syn match	vimAutoCmdSfxList	contained	"\S*"	skipwhite nextgroup=vimAutoCmdMod
    1              0.000013 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
    1              0.000006 syn match	vimAutoCmdMod	"\(++\)\=\(once\|nested\)"
                            
                            " Echo and Execute: -- prefer strings! {{{2
                            " ================
    1              0.000029 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    1              0.000045 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    1              0.000025 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    1              0.000002 syn case ignore
    1              0.000004 syn keyword	vimEchoHLNone	none
    1              0.000001 syn case match
                            
                            " Maps: {{{2
                            " ====
    1              0.000013 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000038 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000014 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000006 syn keyword	vimMap		mapc[lear] smapc[lear]
    1              0.000024 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000013 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    1              0.000022 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    1              0.000026 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000036 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    1              0.000021 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    1              0.000015 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    1              0.000002 syn case ignore
    1              0.000012 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    1              0.000001 syn case match
                            
                            " Menus: {{{2
                            " =====
    1              0.000018 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    1              0.000030 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    1              0.000013 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    1              0.000009 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    1              0.000021 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    1              0.000020 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    1              0.000007 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    1              0.000021 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vim9Comment,vimIsCommand
    1              0.000006 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation: (tnx to Michael Geddes) {{{2
                            " ======================
    1              0.000002 syn case ignore
    1              0.000052 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cmd\|cr\|lf\|linefeed\|return\|enter\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|mouse\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    1              0.000026 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    1              0.000021 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    1              0.000018 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    1              0.000025 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    1              0.000022 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    1              0.000008 syn match	vimBracket contained	"[\\<>]"
    1              0.000001 syn case match
                            
                            " User Function Highlighting: {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    1              0.000093 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    1              0.000024 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
                            
                            " User Command Highlighting: {{{2
    1              0.000006 syn match vimUsrCmd	'^\s*\zs\u\w*.*$'
                            
                            " Errors And Warnings: {{{2
                            " ====================
    1              0.000015 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    1              0.000017  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
    1              0.000017  syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    1              0.000005  syn match	vimElseIfErr	"\<else\s\+if\>"
    1              0.000006  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    1              0.000002 endif
                            
    1              0.000030 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"	skipwhite nextgroup=vimOper,vimOperParen,vimVar,vimFunc,vimNotation
                            
                            " Norm: {{{2
                            " ====
    1              0.000009 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    1              0.000005 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax: {{{2
                            "=======
    1              0.000012 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    1              0.000014 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    1              0.000005 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    1              0.000007 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    1              0.000041  syn match	vimSynError	contained	"\i\+"
    1              0.000012  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    1              0.000009 endif
    1              0.000010 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    1              0.000008 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    1              0.000008 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    1              0.000021 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000020 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment,vim9Comment
    1              0.000014 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    1              0.000009 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    1              0.000007 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    1              0.000005  syn match	vimSynCaseError	contained	"\i\+"
    1              0.000001 endif
    1              0.000003 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    1              0.000006 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    1              0.000006 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    1              0.000030 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    1              0.000008 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    1              0.000007 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    1              0.000012 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    1              0.000006 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    1              0.000006 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    1              0.000004 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    1              0.000006 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    1              0.000006 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    1              0.000012 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    1              0.000006 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    1              0.000018 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    1              0.000012 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    1              0.000007 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    1              0.000029 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation,vim9Comment
    1              0.000007 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    1              0.000015 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    1              0.000013 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    1              0.000004 if has("conceal")
    1              0.000008  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    1              0.000004  syn match	vimSynMtchCchar	contained	"\S"
    1              0.000001 endif
    1              0.000024 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    1              0.000010 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    1              0.000034 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    1              0.000015 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    1              0.000006 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    1              0.000020 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    1              0.000019 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    1              0.000009 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    1              0.000022 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    1              0.000031 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    1              0.000011 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    1              0.000012 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    1              0.000005 syn match	vimSynPatMod	contained	"lc=\d\+"
    1              0.000007 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    1              0.000011 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    1              0.000004 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    1              0.000005 syn match	vimMtchComment	contained	'"[^"]\+$'
    1              0.000007 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    1              0.000021 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    1              0.000009 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    1              0.000005  syn match	vimSyncError	contained	"\i\+"
    1              0.000001 endif
    1              0.000005 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    1              0.000007 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    1              0.000006 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    1              0.000010 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    1              0.000006 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    1              0.000009 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    1              0.000007 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    1              0.000008 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    1              0.000009 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    1              0.000003 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand: here by reasons of precedence {{{2
                            " ====================
    1              0.000018 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting: {{{2
                            " ============
    1              0.000016 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment,vim9Comment
    1              0.000007 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    1              0.000004  syn match	vimHiCtermError	contained	"\D\i*"
    1              0.000001 endif
    1              0.000011 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    1              0.000006 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    1              0.000004 syn match	vimHiGroup	contained	"\i\+"
    1              0.000001 syn case ignore
    1              0.000008 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    1              0.000016 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    1              0.000002 syn case match
    1              0.000006 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    1              0.000009 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    1              0.000002 syn case ignore
    1              0.000081 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    1              0.000022 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    1              0.000001 syn case match
    1              0.000006 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    1              0.000006 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    1              0.000004 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    1              0.000038 syn cluster	vimHiCluster contains=vimGroup,vimHiBlend,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiCtermul,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    1              0.000015 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    1              0.000008 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    1              0.000005  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    1              0.000001 endif
    1              0.000016 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000010 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    1              0.000006 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    1              0.000012 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000012 syn match	vimHiCtermul	contained	"\cctermul="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    1              0.000006 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    1              0.000012 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    1              0.000013 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    1              0.000013 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    1              0.000006 syn match	vimHiBlend	contained	"\cblend="he=e-1		nextgroup=vimHiNmbr
    1              0.000004 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    1              0.000005 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    1              0.000018 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=@vimHiCluster
    1              0.000007 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters: {{{2
                            " ==================
    1              0.000005 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    1              0.000019 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000016 syn match	vim9LineComment	+^[ \t:]\+#.*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    1              0.000021 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    1              0.000008 syn match	vimContinue	"^\s*\\"
    1              0.000024 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    1              0.000005 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    1              0.000009 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    1              0.000005 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    1              0.000028 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    1              0.000019 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Embedded Scripts:  {{{2
                            " ================
                            "   perl,ruby     : Benoit Cerrina
                            "   python,tcl    : Johannes Zellner
                            "   mzscheme, lua : Charles Campbell
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    1              0.000008 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed = 'l'
    1              0.000001 endif
                            
                            " [-- lua --] {{{3
    1              0.000056 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    1              0.000049 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000046 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
    1              0.000004  unlet! b:current_syntax
    1              0.000010  syn cluster vimFuncBodyList	add=vimLuaRegion
    1   0.002090   0.000194  exe "syn include @vimLuaScript ".s:luapath
    1              0.000017  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
    1              0.000008  VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+	contains=@vimLuaScript
    1              0.000005  syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
                             syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000002 unlet s:luapath
                            
                            " [-- perl --] {{{3
    1              0.000055 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    1              0.000038 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000005 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
    1              0.000001 else
    1              0.000007  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    1              0.000018 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    1              0.000026 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000004 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
                             syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
    1              0.000001 else
    1              0.000005  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000034  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:rubypath
                            
                            " [-- python --] {{{3
    1              0.000018 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    1              0.000025 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000004 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon][3x]\=\s*<<\s*$+ end=+\.$+				contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+				contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
    1              0.000001 else
    1              0.000007  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000005  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    1              0.000009 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
    1              0.000001 else
    1              0.000002  let s:trytcl= 1
    1              0.000001 endif
    1              0.000001 if s:trytcl
    1              0.000015  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    1              0.000023  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
    1              0.000001  endif
    1              0.000004  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
    1              0.000001  else
    1              0.000006   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001  endif
    1              0.000001  unlet s:tclpath
                            else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    1              0.000016 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    1              0.000023 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
    1              0.000001 endif
    1              0.000003 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
    1              0.000001 else
    1              0.000006  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    1              0.000004  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    1              0.000001 endif
    1              0.000001 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    1              0.000003 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
    1              0.000001 endif
    1              0.000008 exe "syn sync maxlines=".s:vimsyn_maxlines
    1              0.000003 syn sync linecont	"^\s\+\\"
    1              0.000006 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    1              0.000002 if !exists("skip_vim_syntax_inits")
    1              0.000002  if !exists("g:vimsyn_noerror")
    1              0.000006   hi def link vimBehaveError	vimError
    1              0.000002   hi def link vimCollClassErr	vimError
    1              0.000002   hi def link vimErrSetting	vimError
    1              0.000010   hi def link vimEmbedError	Normal
    1              0.000003   hi def link vimFTError	vimError
    1              0.000002   hi def link vimFunctionError	vimError
    1              0.000114   hi def link vimFunc         	vimError
    1              0.000003   hi def link vimHiAttribList	vimError
    1              0.000002   hi def link vimHiCtermError	vimError
    1              0.000002   hi def link vimHiKeyError	vimError
    1              0.000002   hi def link vimKeyCodeError	vimError
    1              0.000002   hi def link vimMapModErr	vimError
    1              0.000002   hi def link vimSubstFlagErr	vimError
    1              0.000002   hi def link vimSynCaseError	vimError
    1              0.000002   hi def link vimBufnrWarn	vimWarn
    1              0.000001  endif
                            
    1              0.000005  hi def link vimAbb	vimCommand
    1              0.000004  hi def link vimAddress	vimMark
    1              0.000003  hi def link vimAugroupError	vimError
    1              0.000004  hi def link vimAugroupKey	vimCommand
    1              0.000003  hi def link vimAuHighlight	vimHighlight
    1              0.000003  hi def link vimAutoCmdOpt	vimOption
    1              0.000004  hi def link vimAutoCmd	vimCommand
    1              0.000015  hi def link vimAutoEvent	Type
    1              0.000006  hi def link vimAutoCmdMod	Special
    1              0.000003  hi def link vimAutoSet	vimCommand
    1              0.000004  hi def link vimBehaveModel	vimBehave
    1              0.000004  hi def link vimBehave	vimCommand
    1              0.000010  hi def link vimBracket	Delimiter
    1              0.000007  hi def link vimCmplxRepeat	SpecialChar
    1              0.000007  hi def link vimCommand	Statement
    1              0.000007  hi def link vimComment	Comment
    1              0.000007  hi def link vim9Comment	Comment
    1              0.000004  hi def link vimCommentString	vimString
    1              0.000009  hi def link vimCommentTitle	PreProc
    1              0.000003  hi def link vimCondHL	vimCommand
    1              0.000008  hi def link vimContinue	Special
    1              0.000008  hi def link vimCtrlChar	SpecialChar
    1              0.000004  hi def link vimEchoHLNone	vimGroup
    1              0.000004  hi def link vimEchoHL	vimCommand
    1              0.000007  hi def link vimElseIfErr	Error
    1              0.000002  hi def link vimElseif	vimCondHL
    1              0.000007  hi def link vimEnvvar	PreProc
    1              0.000006  hi def link vimError	Error
    1              0.000004  hi def link vimFBVar	vimVar
    1              0.000002  hi def link vimFgBgAttrib	vimHiAttrib
    1              0.000002  hi def link vimHiCtermul	vimHiTerm
    1              0.000009  hi def link vimFold	Folded
    1              0.000004  hi def link vimFTCmd	vimCommand
    1              0.000003  hi def link vimFTOption	vimSynType
    1              0.000004  hi def link vimFuncKey	vimCommand
    1              0.000007  hi def link vimFuncName	Function
    1              0.000008  hi def link vimFuncSID	Special
    1              0.000008  hi def link vimFuncVar	Identifier
    1              0.000002  hi def link vimGroupAdd	vimSynOption
    1              0.000003  hi def link vimGroupName	vimGroup
    1              0.000002  hi def link vimGroupRem	vimSynOption
    1              0.000006  hi def link vimGroupSpecial	Special
    1              0.000007  hi def link vimGroup	Type
    1              0.000006  hi def link vimHiAttrib	PreProc
    1              0.000002  hi def link vimHiBlend	vimHiTerm
    1              0.000003  hi def link vimHiClear	vimHighlight
    1              0.000002  hi def link vimHiCtermFgBg	vimHiTerm
    1              0.000002  hi def link vimHiCTerm	vimHiTerm
    1              0.000004  hi def link vimHighlight	vimCommand
    1              0.000002  hi def link vimHiGroup	vimGroupName
    1              0.000002  hi def link vimHiGuiFgBg	vimHiTerm
    1              0.000002  hi def link vimHiGuiFont	vimHiTerm
    1              0.000003  hi def link vimHiGuiRgb	vimNumber
    1              0.000003  hi def link vimHiGui	vimHiTerm
    1              0.000007  hi def link vimHiNmbr	Number
    1              0.000002  hi def link vimHiStartStop	vimHiTerm
    1              0.000006  hi def link vimHiTerm	Type
    1              0.000004  hi def link vimHLGroup	vimGroup
    1              0.000017  hi def link vimHLMod	PreProc
    1              0.000004  hi def link vimInsert	vimString
    1              0.000008  hi def link vimIskSep	Delimiter
    1              0.000003  hi def link vimKeyCode	vimSpecFile
    1              0.000006  hi def link vimKeyword	Statement
    1              0.000004  hi def link vimLet	vimCommand
    1              0.000004  hi def link vimLetHereDoc	vimString
    1              0.000008  hi def link vimLetHereDocStart	Special
    1              0.000007  hi def link vimLetHereDocStop	Special
    1              0.000004  hi def link vimLineComment	vimComment
    1              0.000003  hi def link vim9LineComment	vimComment
    1              0.000004  hi def link vimMapBang	vimCommand
    1              0.000008  hi def link vimMapModKey	vimFuncSID
    1              0.000006  hi def link vimMapMod	vimBracket
    1              0.000004  hi def link vimMap	vimCommand
    1              0.000008  hi def link vimMark	Number
    1              0.000004  hi def link vimMarkNumber	vimNumber
    1              0.000003  hi def link vimMenuMod	vimMapMod
    1              0.000003  hi def link vimMenuNameMore	vimMenuName
    1              0.000007  hi def link vimMenuName	PreProc
    1              0.000004  hi def link vimMtchComment	vimComment
    1              0.000004  hi def link vimNorm	vimCommand
    1              0.000009  hi def link vimNotation	Special
    1              0.000004  hi def link vimNotFunc	vimCommand
    1              0.000004  hi def link vimNotPatSep	vimString
    1              0.000008  hi def link vimNumber	Number
    1              0.000007  hi def link vimOperError	Error
    1              0.000008  hi def link vimOper	Operator
    1              0.000004  hi def link vimOperStar	vimOper
    1              0.000008  hi def link vimOption	PreProc
    1              0.000007  hi def link vimParenSep	Delimiter
    1              0.000003  hi def link vimPatSepErr	vimError
    1              0.000003  hi def link vimPatSepR	vimPatSep
    1              0.000008  hi def link vimPatSep	SpecialChar
    1              0.000004  hi def link vimPatSepZone	vimString
    1              0.000003  hi def link vimPatSepZ	vimPatSep
    1              0.000008  hi def link vimPattern	Type
    1              0.000004  hi def link vimPlainMark	vimMark
    1              0.000004  hi def link vimPlainRegister	vimRegister
    1              0.000014  hi def link vimRegister	SpecialChar
    1              0.000007  hi def link vimScriptDelim	Comment
    1              0.000006  hi def link vimSearchDelim	Statement
    1              0.000004  hi def link vimSearch	vimString
    1              0.000009  hi def link vimSep	Delimiter
    1              0.000004  hi def link vimSetMod	vimOption
    1              0.000009  hi def link vimSetSep	Statement
    1              0.000004  hi def link vimSetString	vimString
    1              0.000008  hi def link vimSpecFile	Identifier
    1              0.000004  hi def link vimSpecFileMod	vimSpecFile
    1              0.000006  hi def link vimSpecial	Type
    1              0.000006  hi def link vimStatement	Statement
    1              0.000004  hi def link vimStringCont	vimString
    1              0.000008  hi def link vimString	String
    1              0.000004  hi def link vimStringEnd	vimString
    1              0.000004  hi def link vimSubst1	vimSubst
    1              0.000008  hi def link vimSubstDelim	Delimiter
    1              0.000007  hi def link vimSubstFlags	Special
    1              0.000008  hi def link vimSubstSubstr	SpecialChar
    1              0.000004  hi def link vimSubstTwoBS	vimString
    1              0.000004  hi def link vimSubst	vimCommand
    1              0.000008  hi def link vimSynCaseError	Error
    1              0.000008  hi def link vimSynCase	Type
    1              0.000007  hi def link vimSyncC	Type
    1              0.000007  hi def link vimSyncError	Error
    1              0.000003  hi def link vimSyncGroupName	vimGroupName
    1              0.000003  hi def link vimSyncGroup	vimGroupName
    1              0.000008  hi def link vimSyncKey	Type
    1              0.000008  hi def link vimSyncNone	Type
    1              0.000002  hi def link vimSynContains	vimSynOption
    1              0.000007  hi def link vimSynError	Error
    1              0.000004  hi def link vimSynKeyContainedin	vimSynContains
    1              0.000002  hi def link vimSynKeyOpt	vimSynOption
    1              0.000002  hi def link vimSynMtchGrp	vimSynOption
    1              0.000002  hi def link vimSynMtchOpt	vimSynOption
    1              0.000002  hi def link vimSynNextgroup	vimSynOption
    1              0.000003  hi def link vimSynNotPatRange	vimSynRegPat
    1              0.000007  hi def link vimSynOption	Special
    1              0.000004  hi def link vimSynPatRange	vimString
    1              0.000002  hi def link vimSynRegOpt	vimSynOption
    1              0.000003  hi def link vimSynRegPat	vimString
    1              0.000008  hi def link vimSynReg	Type
    1              0.000004  hi def link vimSyntax	vimCommand
    1              0.000002  hi def link vimSynType	vimSpecial
    1              0.000008  hi def link vimTodo	Todo
    1              0.000004  hi def link vimUnmap	vimMap
    1              0.000008  hi def link vimUserAttrbCmpltFunc	Special
    1              0.000003  hi def link vimUserAttrbCmplt	vimSpecial
    1              0.000004  hi def link vimUserAttrbKey	vimOption
    1              0.000003  hi def link vimUserAttrb	vimSpecial
    1              0.000009  hi def link vimUserAttrbError	Error
    1              0.000009  hi def link vimUserCmdError	Error
    1              0.000004  hi def link vimUserCommand	vimCommand
    1              0.000008  hi def link vimUserFunc	Normal
    1              0.000008  hi def link vimVar	Identifier
    1              0.000008  hi def link vimWarn	WarningMsg
                            
    1              0.000003  hi def link nvimAutoEvent	vimAutoEvent
    1              0.000005  hi def link nvimHLGroup	vimHLGroup
    1              0.000003  hi def link nvimMap	vimMap
    1              0.000004  hi def link nvimUnmap	vimUnmap
    1              0.000001 endif
                            
                            " Current Syntax Variable: {{{2
    1              0.000009 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    1              0.000004 delc VimFolda
    1              0.000002 delc VimFoldf
    1              0.000002 delc VimFoldl
    1              0.000002 delc VimFoldm
    1              0.000002 delc VimFoldp
    1              0.000002 delc VimFoldP
    1              0.000002 delc VimFoldr
    1              0.000003 delc VimFoldt
    1              0.000018 let &cpo = s:keepcpo
    1              0.000004 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/syntax/lua.vim
Sourced 1 time
Total time:   0.001869
 Self time:   0.001869

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Lua 4.0, Lua 5.0, Lua 5.1 and Lua 5.2
                            " Maintainer:	Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
                            " First Author:	Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
                            " Last Change:	2012 Aug 12
                            " Options:	lua_version = 4 or 5
                            "		lua_subversion = 0 (4.0, 5.0) or 1 (5.1) or 2 (5.2)
                            "		default 5.2
                            
                            " quit when a syntax file was already loaded
    1              0.000008 if exists("b:current_syntax")
                              finish
    1              0.000001 endif
                            
    1              0.000011 let s:cpo_save = &cpo
    1              0.000012 set cpo&vim
                            
    1              0.000004 if !exists("lua_version")
                              " Default is lua 5.2
                              let lua_version = 5
                              let lua_subversion = 2
    1              0.000004 elseif !exists("lua_subversion")
                              " lua_version exists, but lua_subversion doesn't. So, set it to 0
                              let lua_subversion = 0
    1              0.000001 endif
                            
    1              0.000002 syn case match
                            
                            " syncing method
    1              0.000003 syn sync minlines=100
                            
                            " Comments
    1              0.000006 syn keyword luaTodo            contained TODO FIXME XXX
    1              0.000012 syn match   luaComment         "--.*$" contains=luaTodo,@Spell
    1              0.000003 if lua_version == 5 && lua_subversion == 0
                              syn region luaComment        matchgroup=luaComment start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
                              syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
    1              0.000004 elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
                              " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
    1              0.000015   syn region luaComment        matchgroup=luaComment start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
    1              0.000001 endif
                            
                            " First line may start with #!
    1              0.000005 syn match luaComment "\%^#!.*"
                            
                            " catch errors caused by wrong parenthesis and wrong curly brackets or
                            " keywords placed outside their respective blocks
    1              0.000038 syn region luaParen      transparent                     start='(' end=')' contains=ALLBUT,luaParenError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
    1              0.000032 syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=ALLBUT,luaBraceError,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaBlock,luaLoopBlock,luaIn,luaStatement
                            
    1              0.000004 syn match  luaParenError ")"
    1              0.000003 syn match  luaBraceError "}"
    1              0.000008 syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
                            
                            " function ... end
    1              0.000054 syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " if ... then
    1              0.000026 syn region luaIfThen transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4           contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaIn nextgroup=luaThenEnd skipwhite skipempty
                            
                            " then ... end
    1              0.000019 syn region luaThenEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaThenEnd,luaIn
                            
                            " elseif ... then
    1              0.000023 syn region luaElseifThen contained transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " else
    1              0.000003 syn keyword luaElse contained else
                            
                            " do ... end
    1              0.000023 syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>"          contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " repeat ... until
    1              0.000024 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>"   contains=ALLBUT,luaTodo,luaSpecial,luaElseifThen,luaElse,luaThenEnd,luaIn
                            
                            " while ... do
    1              0.000027 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd,luaIn nextgroup=luaBlock skipwhite skipempty
                            
                            " for ... do and for ... in ... do
    1              0.000020 syn region luaLoopBlock transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2   contains=ALLBUT,luaTodo,luaSpecial,luaIfThen,luaElseifThen,luaElse,luaThenEnd nextgroup=luaBlock skipwhite skipempty
                            
    1              0.000006 syn keyword luaIn contained in
                            
                            " other keywords
    1              0.000005 syn keyword luaStatement return local break
    1              0.000005 if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
    1              0.000004   syn keyword luaStatement goto
    1              0.000006   syn match luaLabel "::\I\i*::"
    1              0.000001 endif
    1              0.000004 syn keyword luaOperator and or not
    1              0.000003 syn keyword luaConstant nil
    1              0.000010 if lua_version > 4
    1              0.000004   syn keyword luaConstant true false
    1              0.000001 endif
                            
                            " Strings
    1              0.000002 if lua_version < 5
                              syn match  luaSpecial contained "\\[\\abfnrtv\'\"]\|\\[[:digit:]]\{,3}"
    1              0.000002 elseif lua_version == 5
    1              0.000002   if lua_subversion == 0
                                syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
                                syn region luaString2 matchgroup=luaString start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
    1              0.000001   else
    1              0.000002     if lua_subversion == 1
                                  syn match  luaSpecial contained #\\[\\abfnrtv'"]\|\\[[:digit:]]\{,3}#
    1              0.000002     else " Lua 5.2
    1              0.000010       syn match  luaSpecial contained #\\[\\abfnrtvz'"]\|\\x[[:xdigit:]]\{2}\|\\[[:digit:]]\{,3}#
    1              0.000001     endif
    1              0.000014     syn region luaString2 matchgroup=luaString start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
    1              0.000001   endif
    1              0.000001 endif
    1              0.000015 syn region luaString  start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
    1              0.000013 syn region luaString  start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
                            
                            " integer number
    1              0.000005 syn match luaNumber "\<\d\+\>"
                            " floating point number, with dot, optional exponent
    1              0.000007 syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, starting with a dot, optional exponent
    1              0.000006 syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
                            " floating point number, without dot, with exponent
    1              0.000006 syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
                            
                            " hex numbers
    1              0.000002 if lua_version >= 5
    1              0.000002   if lua_subversion == 1
                                syn match luaNumber "\<0[xX]\x\+\>"
    1              0.000002   elseif lua_subversion >= 2
    1              0.000008     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
    1              0.000001   endif
    1              0.000001 endif
                            
    1              0.000006 syn keyword luaFunc assert collectgarbage dofile error next
    1              0.000006 syn keyword luaFunc print rawget rawset tonumber tostring type _VERSION
                            
    1              0.000002 if lua_version == 4
                              syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
                              syn keyword luaFunc call copytagmethods dostring
                              syn keyword luaFunc foreach foreachi getglobal getn
                              syn keyword luaFunc gettagmethod globals newtag
                              syn keyword luaFunc setglobal settag settagmethod sort
                              syn keyword luaFunc tag tinsert tremove
                              syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
                              syn keyword luaFunc openfile closefile flush seek
                              syn keyword luaFunc setlocale execute remove rename tmpname
                              syn keyword luaFunc getenv date clock exit
                              syn keyword luaFunc readfrom writeto appendto read write
                              syn keyword luaFunc PI abs sin cos tan asin
                              syn keyword luaFunc acos atan atan2 ceil floor
                              syn keyword luaFunc mod frexp ldexp sqrt min max log
                              syn keyword luaFunc log10 exp deg rad random
                              syn keyword luaFunc randomseed strlen strsub strlower strupper
                              syn keyword luaFunc strchar strrep ascii strbyte
                              syn keyword luaFunc format strfind gsub
                              syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
    1              0.000002 elseif lua_version == 5
    1              0.000004   syn keyword luaFunc getmetatable setmetatable
    1              0.000004   syn keyword luaFunc ipairs pairs
    1              0.000003   syn keyword luaFunc pcall xpcall
    1              0.000004   syn keyword luaFunc _G loadfile rawequal require
    1              0.000002   if lua_subversion == 0
                                syn keyword luaFunc getfenv setfenv
                                syn keyword luaFunc loadstring unpack
                                syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
    1              0.000001   else
    1              0.000003     syn keyword luaFunc load select
    1              0.000007     syn match   luaFunc /\<package\.cpath\>/
    1              0.000005     syn match   luaFunc /\<package\.loaded\>/
    1              0.000005     syn match   luaFunc /\<package\.loadlib\>/
    1              0.000005     syn match   luaFunc /\<package\.path\>/
    1              0.000002     if lua_subversion == 1
                                  syn keyword luaFunc getfenv setfenv
                                  syn keyword luaFunc loadstring module unpack
                                  syn match   luaFunc /\<package\.loaders\>/
                                  syn match   luaFunc /\<package\.preload\>/
                                  syn match   luaFunc /\<package\.seeall\>/
    1              0.000002     elseif lua_subversion == 2
    1              0.000004       syn keyword luaFunc _ENV rawlen
    1              0.000005       syn match   luaFunc /\<package\.config\>/
    1              0.000005       syn match   luaFunc /\<package\.preload\>/
    1              0.000005       syn match   luaFunc /\<package\.searchers\>/
    1              0.000006       syn match   luaFunc /\<package\.searchpath\>/
    1              0.000006       syn match   luaFunc /\<bit32\.arshift\>/
    1              0.000005       syn match   luaFunc /\<bit32\.band\>/
    1              0.000004       syn match   luaFunc /\<bit32\.bnot\>/
    1              0.000004       syn match   luaFunc /\<bit32\.bor\>/
    1              0.000005       syn match   luaFunc /\<bit32\.btest\>/
    1              0.000004       syn match   luaFunc /\<bit32\.bxor\>/
    1              0.000011       syn match   luaFunc /\<bit32\.extract\>/
    1              0.000005       syn match   luaFunc /\<bit32\.lrotate\>/
    1              0.000005       syn match   luaFunc /\<bit32\.lshift\>/
    1              0.000005       syn match   luaFunc /\<bit32\.replace\>/
    1              0.000005       syn match   luaFunc /\<bit32\.rrotate\>/
    1              0.000005       syn match   luaFunc /\<bit32\.rshift\>/
    1              0.000001     endif
    1              0.000006     syn match luaFunc /\<coroutine\.running\>/
    1              0.000001   endif
    1              0.000005   syn match   luaFunc /\<coroutine\.create\>/
    1              0.000005   syn match   luaFunc /\<coroutine\.resume\>/
    1              0.000006   syn match   luaFunc /\<coroutine\.status\>/
    1              0.000005   syn match   luaFunc /\<coroutine\.wrap\>/
    1              0.000006   syn match   luaFunc /\<coroutine\.yield\>/
    1              0.000005   syn match   luaFunc /\<string\.byte\>/
    1              0.000005   syn match   luaFunc /\<string\.char\>/
    1              0.000005   syn match   luaFunc /\<string\.dump\>/
    1              0.000005   syn match   luaFunc /\<string\.find\>/
    1              0.000005   syn match   luaFunc /\<string\.format\>/
    1              0.000005   syn match   luaFunc /\<string\.gsub\>/
    1              0.000005   syn match   luaFunc /\<string\.len\>/
    1              0.000005   syn match   luaFunc /\<string\.lower\>/
    1              0.000005   syn match   luaFunc /\<string\.rep\>/
    1              0.000004   syn match   luaFunc /\<string\.sub\>/
    1              0.000005   syn match   luaFunc /\<string\.upper\>/
    1              0.000003   if lua_subversion == 0
                                syn match luaFunc /\<string\.gfind\>/
    1              0.000002   else
    1              0.000005     syn match luaFunc /\<string\.gmatch\>/
    1              0.000005     syn match luaFunc /\<string\.match\>/
    1              0.000013     syn match luaFunc /\<string\.reverse\>/
    1              0.000001   endif
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<table\.getn\>/
                                syn match luaFunc /\<table\.setn\>/
                                syn match luaFunc /\<table\.foreach\>/
                                syn match luaFunc /\<table\.foreachi\>/
    1              0.000002   elseif lua_subversion == 1
                                syn match luaFunc /\<table\.maxn\>/
    1              0.000002   elseif lua_subversion == 2
    1              0.000005     syn match luaFunc /\<table\.pack\>/
    1              0.000005     syn match luaFunc /\<table\.unpack\>/
    1              0.000001   endif
    1              0.000005   syn match   luaFunc /\<table\.concat\>/
    1              0.000005   syn match   luaFunc /\<table\.sort\>/
    1              0.000004   syn match   luaFunc /\<table\.insert\>/
    1              0.000008   syn match   luaFunc /\<table\.remove\>/
    1              0.000005   syn match   luaFunc /\<math\.abs\>/
    1              0.000005   syn match   luaFunc /\<math\.acos\>/
    1              0.000005   syn match   luaFunc /\<math\.asin\>/
    1              0.000004   syn match   luaFunc /\<math\.atan\>/
    1              0.000005   syn match   luaFunc /\<math\.atan2\>/
    1              0.000008   syn match   luaFunc /\<math\.ceil\>/
    1              0.000004   syn match   luaFunc /\<math\.sin\>/
    1              0.000005   syn match   luaFunc /\<math\.cos\>/
    1              0.000004   syn match   luaFunc /\<math\.tan\>/
    1              0.000004   syn match   luaFunc /\<math\.deg\>/
    1              0.000005   syn match   luaFunc /\<math\.exp\>/
    1              0.000008   syn match   luaFunc /\<math\.floor\>/
    1              0.000005   syn match   luaFunc /\<math\.log\>/
    1              0.000005   syn match   luaFunc /\<math\.max\>/
    1              0.000005   syn match   luaFunc /\<math\.min\>/
    1              0.000002   if lua_subversion == 0
                                syn match luaFunc /\<math\.mod\>/
                                syn match luaFunc /\<math\.log10\>/
    1              0.000001   else
    1              0.000002     if lua_subversion == 1
                                  syn match luaFunc /\<math\.log10\>/
    1              0.000001     endif
    1              0.000005     syn match luaFunc /\<math\.huge\>/
    1              0.000005     syn match luaFunc /\<math\.fmod\>/
    1              0.000007     syn match luaFunc /\<math\.modf\>/
    1              0.000005     syn match luaFunc /\<math\.cosh\>/
    1              0.000004     syn match luaFunc /\<math\.sinh\>/
    1              0.000004     syn match luaFunc /\<math\.tanh\>/
    1              0.000001   endif
    1              0.000004   syn match   luaFunc /\<math\.pow\>/
    1              0.000006   syn match   luaFunc /\<math\.rad\>/
    1              0.000007   syn match   luaFunc /\<math\.sqrt\>/
    1              0.000005   syn match   luaFunc /\<math\.frexp\>/
    1              0.000005   syn match   luaFunc /\<math\.ldexp\>/
    1              0.000006   syn match   luaFunc /\<math\.random\>/
    1              0.000005   syn match   luaFunc /\<math\.randomseed\>/
    1              0.000007   syn match   luaFunc /\<math\.pi\>/
    1              0.000005   syn match   luaFunc /\<io\.close\>/
    1              0.000005   syn match   luaFunc /\<io\.flush\>/
    1              0.000004   syn match   luaFunc /\<io\.input\>/
    1              0.000004   syn match   luaFunc /\<io\.lines\>/
    1              0.000004   syn match   luaFunc /\<io\.open\>/
    1              0.000008   syn match   luaFunc /\<io\.output\>/
    1              0.000004   syn match   luaFunc /\<io\.popen\>/
    1              0.000004   syn match   luaFunc /\<io\.read\>/
    1              0.000005   syn match   luaFunc /\<io\.stderr\>/
    1              0.000004   syn match   luaFunc /\<io\.stdin\>/
    1              0.000005   syn match   luaFunc /\<io\.stdout\>/
    1              0.000004   syn match   luaFunc /\<io\.tmpfile\>/
    1              0.000007   syn match   luaFunc /\<io\.type\>/
    1              0.000004   syn match   luaFunc /\<io\.write\>/
    1              0.000004   syn match   luaFunc /\<os\.clock\>/
    1              0.000004   syn match   luaFunc /\<os\.date\>/
    1              0.000005   syn match   luaFunc /\<os\.difftime\>/
    1              0.000005   syn match   luaFunc /\<os\.execute\>/
    1              0.000007   syn match   luaFunc /\<os\.exit\>/
    1              0.000055   syn match   luaFunc /\<os\.getenv\>/
    1              0.000019   syn match   luaFunc /\<os\.remove\>/
    1              0.000008   syn match   luaFunc /\<os\.rename\>/
    1              0.000005   syn match   luaFunc /\<os\.setlocale\>/
    1              0.000004   syn match   luaFunc /\<os\.time\>/
    1              0.000011   syn match   luaFunc /\<os\.tmpname\>/
    1              0.000012   syn match   luaFunc /\<debug\.debug\>/
    1              0.000016   syn match   luaFunc /\<debug\.gethook\>/
    1              0.000004   syn match   luaFunc /\<debug\.getinfo\>/
    1              0.000005   syn match   luaFunc /\<debug\.getlocal\>/
    1              0.000024   syn match   luaFunc /\<debug\.getupvalue\>/
    1              0.000004   syn match   luaFunc /\<debug\.setlocal\>/
    1              0.000004   syn match   luaFunc /\<debug\.setupvalue\>/
    1              0.000004   syn match   luaFunc /\<debug\.sethook\>/
    1              0.000004   syn match   luaFunc /\<debug\.traceback\>/
    1              0.000059   if lua_subversion == 1
                                syn match luaFunc /\<debug\.getfenv\>/
                                syn match luaFunc /\<debug\.setfenv\>/
                                syn match luaFunc /\<debug\.getmetatable\>/
                                syn match luaFunc /\<debug\.setmetatable\>/
                                syn match luaFunc /\<debug\.getregistry\>/
    1              0.000005   elseif lua_subversion == 2
    1              0.000007     syn match luaFunc /\<debug\.getmetatable\>/
    1              0.000004     syn match luaFunc /\<debug\.setmetatable\>/
    1              0.000004     syn match luaFunc /\<debug\.getregistry\>/
    1              0.000004     syn match luaFunc /\<debug\.getuservalue\>/
    1              0.000004     syn match luaFunc /\<debug\.setuservalue\>/
    1              0.000005     syn match luaFunc /\<debug\.upvalueid\>/
    1              0.000004     syn match luaFunc /\<debug\.upvaluejoin\>/
    1              0.000001   endif
    1              0.000001 endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    1              0.000018 hi def link luaStatement		Statement
    1              0.000004 hi def link luaRepeat		Repeat
    1              0.000003 hi def link luaFor			Repeat
    1              0.000004 hi def link luaString		String
    1              0.000004 hi def link luaString2		String
    1              0.000004 hi def link luaNumber		Number
    1              0.000004 hi def link luaOperator		Operator
    1              0.000005 hi def link luaIn			Operator
    1              0.000003 hi def link luaConstant		Constant
    1              0.000003 hi def link luaCond		Conditional
    1              0.000003 hi def link luaElse		Conditional
    1              0.000004 hi def link luaFunction		Function
    1              0.000004 hi def link luaComment		Comment
    1              0.000003 hi def link luaTodo		Todo
    1              0.000004 hi def link luaTable		Structure
    1              0.000004 hi def link luaError		Error
    1              0.000003 hi def link luaParenError		Error
    1              0.000003 hi def link luaBraceError		Error
    1              0.000004 hi def link luaSpecial		SpecialChar
    1              0.000004 hi def link luaFunc		Identifier
    1              0.000004 hi def link luaLabel		Label
                            
                            
    1              0.000004 let b:current_syntax = "lua"
                            
    1              0.000012 let &cpo = s:cpo_save
    1              0.000002 unlet s:cpo_save
                            " vim: et ts=8 sw=2

SCRIPT  /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/syntax/vim/generated.vim
Sourced 3 times
Total time:   0.005454
 Self time:   0.005454

count  total (s)   self (s)
    3              0.001834 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bal[t] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cabo[ve] cad[dbuffer] cadde[xpr] caddf[ile] caf[ter] cal[l] cat[ch] cb[uffer] cbe[fore] cbel[ow] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev]
    3              0.000406 syn keyword vimCommand contained  cnorem[enu] co[py] col[der] colo[rscheme] com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cons[t] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ev[al] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags]
    3              0.000231 syn keyword vimCommand contained  ha[rdcopy] hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev] iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lab[ove] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] laf[ter] lat[er] lb[uffer] lbe[fore] lbel[ow] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd]
    3              0.000256 syn keyword vimCommand contained  lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate] mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] perlf[ile] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead]
    3              0.000222 syn keyword vimCommand contained  rec[over] red[o] redi[r] redr[aw] redraws[tatus] redrawt[abline] reg[isters] res[ize] ret[ab] retu[rn] rew[ind] ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellra[re] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu]
    3              0.000220 syn keyword vimCommand contained  sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit] tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[enu] tma[p] tmapc[lear] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmenu] tunma[p] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo] wv[iminfo]
    3              0.000031 syn keyword vimCommand contained  x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    3              0.000094 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl
    3              0.000194 syn keyword vimOption contained  buftype bt casemap cmp cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot completeslash csl confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    3              0.000102 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
    3              0.000087 syn keyword vimOption contained  foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic imcmdline imc invimcmdline noimcmdline invimc noimc
    3              0.000078 syn keyword vimOption contained  imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs jumpoptions jop keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl
    3              0.000073 syn keyword vimOption contained  magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelineexpr mle invmodelineexpr nomodelineexpr invmle nomle modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste pastetoggle pt
    3              0.000082 syn keyword vimOption contained  patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumblend pb pumheight ph pumwidth pw pyxversion pyx quickfixtextfunc qftf quoteescape qe readonly ro invreadonly noreadonly invro noro redrawdebug rdb redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk
    3              0.000077 syn keyword vimOption contained  scrollbind scb invscrollbind noscrollbind invscb noscb scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs
    3              0.000078 syn keyword vimOption contained  smartindent si invsmartindent nosmartindent invsi nosi smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps spelloptions spo splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tagfunc tfu tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi
    3              0.000080 syn keyword vimOption contained  termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc termpastefilter tpf terse invterse noterse textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut varsofttabstop vsts vartabstop vts verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi viminfofile vif virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu
    3              0.000046 syn keyword vimOption contained  wildmode wim wildoptions wop winaltkeys wak winblend winbl winhighlight winhl window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    3              0.000005 syn case ignore
                            
    3              0.000122 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdUndefined CmdWinEnter CmdWinLeave CmdlineChanged CmdlineEnter CmdlineLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CompleteDonePre CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave InsertLeavePre
    3              0.000055 syn keyword vimAutoEvent contained  MenuPopup OptionSet QuickFixCmdPost QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePost SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermEnter TermLeave TermResponse TextChanged TextChangedI TextChangedP TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinEnter WinLeave WinNew BufWrite FileEncoding BufCreate BufRead
                            
    3              0.000021 syn keyword nvimAutoEvent contained  Signal DirChanged BufModifiedSet WinScrolled UIEnter TabClosed WinClosed UILeave TabNew TabNewEntered TermOpen TermClose
                            
    3              0.000003 syn case match
                            
    3              0.000474 syn keyword vimFuncName contained  copy extend setpos setqflist setreg settabvar settabwinvar settagstack setwinvar sha256 shellescape sign_define sign_getdefined sign_getplaced sign_jump sign_place sign_placelist sign_undefine sign_unplace sign_unplacelist simplify sockconnect soundfold stdioopen spellbadword stdpath str2float str2list str2nr strcharpart strchars strdisplaywidth strftime strgetchar stridx strlen strpart strptime strridx strtrans strwidth submatch swapinfo synID synIDattr synIDtrans synconcealed synstack system systemlist tabpagebuflist tabpagenr winrestview winsaveview wordcount writefile xor termopen test_garbagecollect_now test_write_list_log nvim_buf_line_count timer_pause timer_start timer_stop timer_stopall tolower toupper trim nvim_buf_attach getmarklist undotree uniq values virtcol visualmode wait wildmenumode win_execute
    3              0.000080 syn keyword vimFuncName contained  win_findbuf win_getid nvim_buf_get_lines win_gotoid win_id2tabwin nvim_buf_set_lines win_screenpos win_splitmove nvim_buf_set_text wincol windowsversion winlayout nvim_buf_get_offset nvim_buf_get_var winrestcmd nvim_buf_get_changedtick nvim_buf_get_keymap nvim_buf_set_keymap getwinpos gettabvar gettabinfo nvim_buf_del_keymap tr nvim_buf_get_commands nvim_buf_set_var nvim_replace_termcodes nvim_buf_del_var nvim_buf_get_option winheight undofile winwidth libcall libcallnr line line2byte lispindent list2str localtime luaeval maparg mapcheck matchadd environ matcharg matchdelete matchend matchlist matchstr expandcmd feedkeys mkdir msgpackdump msgpackparse filewritable finddir pathshorten flatten float2nr fnameescape fnamemodify foldclosed foldclosedend foldtextresult foreground funcref garbagecollect get getbufinfo
    3              0.000077 syn keyword vimFuncName contained  getbufline getbufvar getchangelist getchar getcharmod getcharsearch getcmdline getcmdpos getcmdtype getcmdwintype getcompletion getcurpos getcwd getfontname getfperm getfsize add api_info appendbufline argc argidx arglistid argv getpos assert_beeps assert_equal assert_equalfile browsedir assert_fails assert_false assert_inrange assert_match assert_nobeep getwinposx getwinposy getwinvar buflisted glob2regpat globpath has has_key haslocaldir hasmapto highlightID ctxsize highlight_exists debugbreak histadd histdel histget histnr hlID hlexists hostname iconv indent index inputdialog inputlist inputrestore nvim_strwidth getreg getmatches getpid getregtype gettabwinvar gettagstack getwininfo jobstop jobwait getqflist winnr winline eval winbufnr win_id2win win_gettype filter assert_notequal assert_report assert_true
    3              0.000068 syn keyword vimFuncName contained  getjumplist trunc getloclist getline getftype getftime assert_notmatch dictwatcherdel timer_info resolve round tempname rpcnotify rpcrequest taglist tagfiles tabpagewinnr rpcstop screenattr screencol screenpos screenrow searchcount searchdecl searchpair searchpairpos searchpos serverlist serverstart serverstop setbufline setbufvar setcharsearch setcmdpos setenv setfperm setline setloclist nvim_feedkeys nvim_input nvim_input_mouse nvim_eval nvim_notify join nvim_call_function nvim_call_dict_function nvim_list_runtime_paths nvim_get_runtime_file nvim__get_lib_dir nvim_set_current_dir nvim_get_current_line nvim_set_current_line nvim_del_current_line nvim_get_var nvim_set_var nvim_del_var nvim_get_vvar nvim_set_vvar nvim_get_option nvim_get_all_options_info nvim_get_option_info nvim_set_option nvim_echo nvim_out_write
    3              0.000074 syn keyword vimFuncName contained  nvim_err_write nvim_err_writeln nvim_list_bufs nvim_get_current_buf nvim_set_current_buf nvim_list_wins nvim_get_current_win nvim_set_current_win nvim_create_buf nvim_open_term nvim_open_win nvim_list_tabpages nvim_get_current_tabpage nvim_set_current_tabpage nvim_create_namespace nvim_get_namespaces nvim_paste nvim_put nvim_get_color_by_name nvim_get_color_map nvim_get_context map nvim_load_context nvim_get_mode nvim_get_keymap nvim_set_keymap nvim_del_keymap nvim_get_commands nvim_get_chan_info nvim_list_chans mode nvim_parse_expression nvim__id nvim__id_array nvim__id_dictionary nvim__id_float nvim__stats nvim_list_uis nvim_buf_set_option nvim_get_proc_children nvim_get_proc nvim_buf_get_name nvim_select_popupmenu_item nvim_buf_set_name nvim__inspect_cell nvim_buf_is_loaded nvim__screenshot nvim_buf_delete
    3              0.000067 syn keyword vimFuncName contained  nvim_win_get_buf nvim_buf_is_valid nvim_win_set_buf nvim_buf_get_mark nvim_win_get_cursor nvim_buf_get_extmark_by_id nvim_buf_get_extmarks nvim_buf_set_extmark nvim_buf_del_extmark nvim_buf_add_highlight nvim_buf_clear_namespace nvim_buf_set_virtual_text nvim__buf_stats nvim_command_output nvim_buf_get_number nvim_buf_clear_highlight nvim_tabpage_list_wins nvim_tabpage_get_var nvim_tabpage_set_var nvim_tabpage_del_var nvim_tabpage_get_win nvim_tabpage_get_number nvim_tabpage_is_valid nvim_exec nvim_command substitute nvim_get_hl_by_name nvim_get_hl_by_id nvim_get_hl_id_by_name nvim__get_hl_defs nvim_set_hl nvim__set_hl_ns and function or repeat string split type append swapname shiftwidth insert remove sort input execute rename getenv len reverse match abs floor ceil spellsuggest log10 exp confirm cos tan
    3              0.000084 syn keyword vimFuncName contained  asin acos atan sinh cosh tanh log atan2 pow fmod min max sin complete foldtext diff_hlID empty escape executable exepath exists matchstrpos menu_get expand nextnonblank nr2char prevnonblank printf prompt_getprompt prompt_setinterrupt pum_getpos py3eval last_buffer_nr pyxeval range foldlevel readfile jobstart reg_recording matchaddpos reltimefloat keys bufexists json_decode rpcstart delete buffer_number cindent bufload bufname file_readable bufwinid byte2line byteidxcomp deletebufline deepcopy cursor search ctxset ctxpush ctxpop ctxget cscope_connection count complete_info complete_check complete_add col clearmatches charidx char2nr chansend chanclose changenr nvim_win_set_cursor byteidx nvim_win_get_height bufwinnr nvim_win_set_height bufnr nvim_win_get_width bufloaded nvim_win_set_width screenchar nvim_win_get_var
    3              0.000060 syn keyword vimFuncName contained  rubyeval nvim_win_set_var buffer_name nvim_win_del_var buffer_exists nvim_win_get_option bufadd nvim_win_set_option reltimestr nvim_win_get_position reltime nvim_win_get_tabpage reg_executing nvim_win_get_number readdir nvim_win_is_valid perleval nvim_win_set_config pyeval nvim_win_get_config pumvisible nvim_win_hide prompt_setprompt nvim_win_close prompt_setcallback inputsave inputsecret interrupt invert isdirectory isinf islocked isnan id items jobclose eventhandler jobpid jobresize jobsend diff_filler did_filetype dictwatcheradd call browse assert_exception glob findfile json_encode filereadable setmatches sqrt

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/compe.vim
Sourced 1 time
Total time:   0.008605
 Self time:   0.002690

count  total (s)   self (s)
    1   0.006342   0.000428 let s:Window = vital#compe#import('VS.Vim.Window')
                            
                            "
                            " Public API
                            "
                            
                            "
                            " compe#setup
                            "
    1              0.000004 function! compe#setup(config, ...) abort
                              call luaeval('require"compe".setup(_A[1], _A[2])', [a:config, get(a:, 1, v:null)])
                            endfunction
                            
                            "
                            " compe#register_source
                            "
    1              0.000004 function! compe#register_source(name, source) abort
                              if matchstr(a:name, '^\w\+$') ==# ''
                                throw "compe: the source's name must be \w\+"
                              endif
                              return compe#vim_bridge#register(a:name, a:source)
                            endfunction
                            
                            "
                            " compe#register_source
                            "
    1              0.000003 function! compe#unregister_source(id) abort
                              call compe#vim_bridge#unregister(a:id)
                            endfunction
                            
                            "
                            " compe#complete
                            "
    1              0.000002 function! compe#complete(...) abort
                              if mode()[0] ==# 'i'
                                call timer_start(0, { -> luaeval('require"compe"._complete(_A)', { 'manual': v:true }) })
                              endif
                              return "\<Ignore>"
                            endfunction
                            
                            "
                            " confirm
                            "
    1              0.000026 inoremap <silent> <Plug>(compe-confirm) <C-r>=luaeval('require"compe"._confirm()')<CR>
    1              0.000002 function! compe#confirm(...) abort
                              let l:completeopts = split(&completeopt, ',')
                              for l:opt in ['menuone', 'noselect']
                                if index(l:completeopts, l:opt) == -1
                                  echohl ErrorMsg
                                  echomsg '[nvim-compe] You must set `set completeopt=menuone,noselect` in your vimrc.'
                                  echohl None
                                endif
                              endfor
                            
                              let l:option = s:normalize(get(a:000, 0, {}))
                              let l:index = complete_info(['selected']).selected
                              let l:select = get(l:option, 'select', v:false)
                              let l:selected = l:index != -1
                              if mode()[0] ==# 'i' && pumvisible() && (l:select || l:selected)
                                let l:info = luaeval('require"compe"._confirm_pre(_A)', (l:selected ? l:index + 1 : 1))
                                if !empty(l:info)
                                  call feedkeys(repeat("\<BS>", strchars(getline('.')[l:info.offset - 1 : col('.') - 2], 1)), 'n')
                                  call feedkeys(l:info.item.word, 'n')
                                  call feedkeys("\<Plug>(compe-confirm)", '')
                                else
                                  return "\<C-y>" " fallback for other plugin's completion menu
                                endif
                                return "\<Ignore>"
                              endif
                              return s:fallback(l:option)
                            endfunction
                            
                            "
                            " compe#close
                            "
    1              0.000002 function! compe#close(...) abort
                              if mode()[0] ==# 'i' && pumvisible()
                                return "\<C-e>\<C-r>=luaeval('require\"compe\"._close()')\<CR>"
                              endif
                              return s:fallback(s:normalize(get(a:000, 0, {})))
                            endfunction
                            
                            "
                            " compe#scroll
                            "
    1              0.000002 function! compe#scroll(option) abort
                              let l:delta = get(a:option, 'delta', 4)
                              let l:foo = luaeval('require("compe.float").scroll(_A)', l:delta)
                              return "\<Ignore>"
                            endfunction
                            
                            "
                            " Private API
                            "
                            
                            "
                            " compe#_is_selected_manually
                            "
    1              0.000002 function! compe#_is_selected_manually() abort
                              return pumvisible() && !empty(v:completed_item) ? v:true : v:false
                            endfunction
                            
                            "
                            " compe#_has_completed_item
                            "
    1              0.000002 function! compe#_has_completed_item() abort
                              return !empty(v:completed_item) ? v:true : v:false
                            endfunction
                            
                            "
                            " normalize
                            "
    1              0.000003 function! s:normalize(option) abort
                              if type(a:option) == v:t_string
                                return { 'keys': a:option, 'mode': 'n' }
                              endif
                              return a:option
                            endfunction
                            
                            "
                            " fallback
                            "
    1              0.000003 function! s:fallback(option) abort
                              if has_key(a:option, 'keys') && get(a:option, 'mode', 'n') !=# 'n'
                                call feedkeys(a:option.keys, a:option.mode)
                                return "\<Ignore>"
                              endif
                              return get(a:option, 'keys', "\<Ignore>")
                            endfunction
                            

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim
Sourced 1 time
Total time:   0.003142
 Self time:   0.003142

count  total (s)   self (s)
    1              0.000032 let s:plugin_name = expand('<sfile>:t:r')
    1              0.000008 let s:vital_base_dir = expand('<sfile>:h')
    1              0.000006 let s:project_root = expand('<sfile>:h:h:h')
    1              0.000006 let s:is_vital_vim = s:plugin_name is# 'vital'
                            
    1              0.000004 let s:loaded = {}
    1              0.000003 let s:cache_sid = {}
                            
    1              0.000009 function! vital#{s:plugin_name}#new() abort
                              return s:new(s:plugin_name)
                            endfunction
                            
    1              0.000005 function! vital#{s:plugin_name}#import(...) abort
                              if !exists('s:V')
                                let s:V = s:new(s:plugin_name)
                              endif
                              return call(s:V.import, a:000, s:V)
                            endfunction
                            
    1              0.000003 let s:Vital = {}
                            
    1              0.000027 function! s:new(plugin_name) abort
                              let base = deepcopy(s:Vital)
                              let base._plugin_name = a:plugin_name
                              return base
                            endfunction
                            
    1              0.000003 function! s:vital_files() abort
                              if !exists('s:vital_files')
                                let s:vital_files = map(
                                \   s:is_vital_vim ? s:_global_vital_files() : s:_self_vital_files(),
                                \   'fnamemodify(v:val, ":p:gs?[\\\\/]?/?")')
                              endif
                              return copy(s:vital_files)
                            endfunction
    1              0.000012 let s:Vital.vital_files = function('s:vital_files')
                            
    1              0.000003 function! s:import(name, ...) abort dict
                              let target = {}
                              let functions = []
                              for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
                              let module = self._import(a:name)
                              if empty(functions)
                                call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
                              return target
                            endfunction
    1              0.000008 let s:Vital.import = function('s:import')
                            
    1              0.000002 function! s:load(...) abort dict
                              for arg in a:000
                                let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
                                let target = split(join(as, ''), '\W\+')
                                let dict = self
                                let dict_type = type({})
                                while !empty(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == dict_type
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                                if exists('dict')
                                  call extend(dict, self._import(name))
                                endif
                                unlet arg
                              endfor
                              return self
                            endfunction
    1              0.000009 let s:Vital.load = function('s:load')
                            
    1              0.000002 function! s:unload() abort dict
                              let s:loaded = {}
                              let s:cache_sid = {}
                              unlet! s:vital_files
                            endfunction
    1              0.000006 let s:Vital.unload = function('s:unload')
                            
    1              0.000003 function! s:exists(name) abort dict
                              if a:name !~# '\v^\u\w*%(\.\u\w*)*$'
                                throw 'vital: Invalid module name: ' . a:name
                              endif
                              return s:_module_path(a:name) isnot# ''
                            endfunction
    1              0.000007 let s:Vital.exists = function('s:exists')
                            
    1              0.000003 function! s:search(pattern) abort dict
                              let paths = s:_extract_files(a:pattern, self.vital_files())
                              let modules = sort(map(paths, 's:_file2module(v:val)'))
                              return uniq(modules)
                            endfunction
    1              0.000006 let s:Vital.search = function('s:search')
                            
    1              0.000002 function! s:plugin_name() abort dict
                              return self._plugin_name
                            endfunction
    1              0.000007 let s:Vital.plugin_name = function('s:plugin_name')
                            
    1              0.000003 function! s:_self_vital_files() abort
                              let builtin = printf('%s/__%s__/', s:vital_base_dir, s:plugin_name)
                              let installed = printf('%s/_%s/', s:vital_base_dir, s:plugin_name)
                              let base = builtin . ',' . installed
                              return split(globpath(base, '**/*.vim', 1), "\n")
                            endfunction
                            
    1              0.000003 function! s:_global_vital_files() abort
                              let pattern = 'autoload/vital/__*__/**/*.vim'
                              return split(globpath(&runtimepath, pattern, 1), "\n")
                            endfunction
                            
    1              0.000003 function! s:_extract_files(pattern, files) abort
                              let tr = {'.': '/', '*': '[^/]*', '**': '.*'}
                              let target = substitute(a:pattern, '\.\|\*\*\?', '\=tr[submatch(0)]', 'g')
                              let regexp = printf('autoload/vital/[^/]\+/%s.vim$', target)
                              return filter(a:files, 'v:val =~# regexp')
                            endfunction
                            
    1              0.000003 function! s:_file2module(file) abort
                              let filename = fnamemodify(a:file, ':p:gs?[\\/]?/?')
                              let tail = matchstr(filename, 'autoload/vital/_\w\+/\zs.*\ze\.vim$')
                              return join(split(tail, '[\\/]\+'), '.')
                            endfunction
                            
                            " @param {string} name e.g. Data.List
    1              0.000002 function! s:_import(name) abort dict
                              if has_key(s:loaded, a:name)
                                return copy(s:loaded[a:name])
                              endif
                              let module = self._get_module(a:name)
                              if has_key(module, '_vital_created')
                                call module._vital_created(module)
                              endif
                              let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module._vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
                              let s:loaded[a:name] = export_module
                              if has_key(module, '_vital_loaded')
                                try
                                  call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception . " from:\n" . s:_format_throwpoint(v:throwpoint)
                                endtry
                              endif
                              return copy(s:loaded[a:name])
                            endfunction
    1              0.000028 let s:Vital._import = function('s:_import')
                            
    1              0.000006 function! s:_format_throwpoint(throwpoint) abort
                              let funcs = []
                              let stack = matchstr(a:throwpoint, '^function \zs.*, .\{-} \d\+$')
                              for line in split(stack, '\.\.')
                                let m = matchlist(line, '^\(.\+\)\%(\[\(\d\+\)\]\|, .\{-} \(\d\+\)\)$')
                                if !empty(m)
                                  let [name, lnum, lnum2] = m[1:3]
                                  if empty(lnum)
                                    let lnum = lnum2
                                  endif
                                  let info = s:_get_func_info(name)
                                  if !empty(info)
                                    let attrs = empty(info.attrs) ? '' : join([''] + info.attrs)
                                    let flnum = info.lnum == 0 ? '' : printf(' Line:%d', info.lnum + lnum)
                                    call add(funcs, printf('function %s(...)%s Line:%d (%s%s)',
                                    \        info.funcname, attrs, lnum, info.filename, flnum))
                                    continue
                                  endif
                                endif
                                " fallback when function information cannot be detected
                                call add(funcs, line)
                              endfor
                              return join(funcs, "\n")
                            endfunction
                            
    1              0.000003 function! s:_get_func_info(name) abort
                              let name = a:name
                              if a:name =~# '^\d\+$'  " is anonymous-function
                                let name = printf('{%s}', a:name)
                              elseif a:name =~# '^<lambda>\d\+$'  " is lambda-function
                                let name = printf("{'%s'}", a:name)
                              endif
                              if !exists('*' . name)
                                return {}
                              endif
                              let body = execute(printf('verbose function %s', name))
                              let lines = split(body, "\n")
                              let signature = matchstr(lines[0], '^\s*\zs.*')
                              let [_, file, lnum; __] = matchlist(lines[1],
                              \   '^\t\%(Last set from\|.\{-}:\)\s*\zs\(.\{-}\)\%( \S\+ \(\d\+\)\)\?$')
                              return {
                              \   'filename': substitute(file, '[/\\]\+', '/', 'g'),
                              \   'lnum': 0 + lnum,
                              \   'funcname': a:name,
                              \   'arguments': split(matchstr(signature, '(\zs.*\ze)'), '\s*,\s*'),
                              \   'attrs': filter(['dict', 'abort', 'range', 'closure'], 'signature =~# (").*" . v:val)'),
                              \ }
                            endfunction
                            
                            " s:_get_module() returns module object wihch has all script local functions.
    1              0.000003 function! s:_get_module(name) abort dict
                              let funcname = s:_import_func_name(self.plugin_name(), a:name)
                              try
                                return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117:/
                                return s:_get_builtin_module(a:name)
                              endtry
                            endfunction
                            
    1              0.000003 function! s:_get_builtin_module(name) abort
                             return s:sid2sfuncs(s:_module_sid(a:name))
                            endfunction
                            
    1              0.000003 if s:is_vital_vim
                              " For vital.vim, we can use s:_get_builtin_module directly
                              let s:Vital._get_module = function('s:_get_builtin_module')
    1              0.000003 else
    1              0.000008   let s:Vital._get_module = function('s:_get_module')
    1              0.000002 endif
                            
    1              0.000004 function! s:_import_func_name(plugin_name, module_name) abort
                              return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))
                            endfunction
                            
    1              0.000002 function! s:_module_sid(name) abort
                              let path = s:_module_path(a:name)
                              if !filereadable(path)
                                throw 'vital: module not found: ' . a:name
                              endif
                              let vital_dir = s:is_vital_vim ? '__\w\+__' : printf('_\{1,2}%s\%%(__\)\?', s:plugin_name)
                              let base = join([vital_dir, ''], '[/\\]\+')
                              let p = base . substitute('' . a:name, '\.', '[/\\\\]\\+', 'g')
                              let sid = s:_sid(path, p)
                              if !sid
                                call s:_source(path)
                                let sid = s:_sid(path, p)
                                if !sid
                                  throw printf('vital: cannot get <SID> from path: %s', path)
                                endif
                              endif
                              return sid
                            endfunction
                            
    1              0.000002 function! s:_module_path(name) abort
                              return get(s:_extract_files(a:name, s:vital_files()), 0, '')
                            endfunction
                            
    1              0.000002 function! s:_module_sid_base_dir() abort
                              return s:is_vital_vim ? &rtp : s:project_root
                            endfunction
                            
    1              0.000002 function! s:_dot_to_sharp(name) abort
                              return substitute(a:name, '\.', '#', 'g')
                            endfunction
                            
    1              0.000004 function! s:_source(path) abort
                              execute 'source' fnameescape(a:path)
                            endfunction
                            
                            " @vimlint(EVL102, 1, l:_)
                            " @vimlint(EVL102, 1, l:__)
    1              0.000003 function! s:_sid(path, filter_pattern) abort
                              let unified_path = s:_unify_path(a:path)
                              if has_key(s:cache_sid, unified_path)
                                return s:cache_sid[unified_path]
                              endif
                              for line in filter(split(execute(':scriptnames'), "\n"), 'v:val =~# a:filter_pattern')
                                let [_, sid, path; __] = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
                                if s:_unify_path(path) is# unified_path
                                  let s:cache_sid[unified_path] = sid
                                  return s:cache_sid[unified_path]
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000164 if filereadable(expand('<sfile>:r') . '.VIM') " is case-insensitive or not
    1              0.000011   let s:_unify_path_cache = {}
                              " resolve() is slow, so we cache results.
                              " Note: On windows, vim can't expand path names from 8.3 formats.
                              " So if getting full path via <sfile> and $HOME was set as 8.3 format,
                              " vital load duplicated scripts. Below's :~ avoid this issue.
    1              0.000006   function! s:_unify_path(path) abort
                                if has_key(s:_unify_path_cache, a:path)
                                  return s:_unify_path_cache[a:path]
                                endif
                                let value = tolower(fnamemodify(resolve(fnamemodify(
                                \                   a:path, ':p')), ':~:gs?[\\/]?/?'))
                                let s:_unify_path_cache[a:path] = value
                                return value
                              endfunction
                            else
                              function! s:_unify_path(path) abort
                                return resolve(fnamemodify(a:path, ':p:gs?[\\/]?/?'))
                              endfunction
    1              0.000002 endif
                            
                            " copied and modified from Vim.ScriptLocal
    1              0.000063 let s:SNR = join(map(range(len("\<SNR>")), '"[\\x" . printf("%0x", char2nr("\<SNR>"[v:val])) . "]"'), '')
    1              0.000004 function! s:sid2sfuncs(sid) abort
                              let fs = split(execute(printf(':function /^%s%s_', s:SNR, a:sid)), "\n")
                              let r = {}
                              let pattern = printf('\m^function\s<SNR>%d_\zs\w\{-}\ze(', a:sid)
                              for fname in map(fs, 'matchstr(v:val, pattern)')
                                let r[fname] = function(s:_sfuncname(a:sid, fname))
                              endfor
                              return r
                            endfunction
                            
                            "" Return funcname of script local functions with SID
    1              0.000003 function! s:_sfuncname(sid, funcname) abort
                              return printf('<SNR>%s_%s', a:sid, a:funcname)
                            endfunction

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Window.vim
Sourced 1 time
Total time:   0.000730
 Self time:   0.000697

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000039 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000103   0.000070 execute join(['function! vital#_compe#VS#Vim#Window#import() abort', printf("return map({'info': '', 'do': '', 'is_floating': '', 'find': '', 'scroll': '', 'screenpos': ''}, \"vital#_compe#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000008 delfunction s:_SID
                            " ___vital___
    1              0.000009 let s:Do = { -> {} }
                            
                            "
                            " do
                            "
    1              0.000004 function! s:do(winid, func) abort
                              let l:curr_winid = win_getid()
                              if l:curr_winid == a:winid
                                call a:func()
                                return
                              endif
                            
                              if !has('nvim') && exists('*win_execute')
                                let s:Do = a:func
                                try
                                  noautocmd keepalt keepjumps call win_execute(a:winid, 'call s:Do()')
                                catch /.*/
                                  echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                                endtry
                                unlet s:Do
                                return
                              endif
                            
                              noautocmd keepalt keepjumps call win_gotoid(a:winid)
                              try
                                call a:func()
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                              endtry
                              noautocmd keepalt keepjumps call win_gotoid(l:curr_winid)
                            endfunction
                            
                            "
                            " info
                            "
    1              0.000007 if has('nvim')
    1              0.000003   function! s:info(winid) abort
                                let l:info = getwininfo(a:winid)[0]
                                return {
                                \   'width': l:info.width,
                                \   'height': l:info.height,
                                \   'topline': l:info.topline,
                                \ }
                              endfunction
                            else
                              function! s:info(winid) abort
                                if s:is_floating(a:winid)
                                  let l:info = popup_getpos(a:winid)
                                  return {
                                  \   'width': l:info.width,
                                  \   'height': l:info.height,
                                  \   'topline': l:info.firstline
                                  \ }
                                endif
                            
                                let l:ctx = {}
                                let l:ctx.info = {}
                                function! l:ctx.callback() abort
                                  let self.info.width = winwidth(0)
                                  let self.info.height = winheight(0)
                                  let self.info.topline = line('w0')
                                endfunction
                                call s:do(a:winid, { -> l:ctx.callback() })
                                return l:ctx.info
                              endfunction
    1              0.000002 endif
                            
                            "
                            " find
                            "
    1              0.000003 function! s:find(callback) abort
                              let l:winids = []
                              let l:winids += map(range(1, tabpagewinnr(tabpagenr(), '$')), 'win_getid(v:val)')
                              let l:winids += s:_get_visible_popup_winids()
                              return filter(l:winids, 'a:callback(v:val)')
                            endfunction
                            
                            "
                            " is_floating
                            "
    1              0.000005 if has('nvim')
    1              0.000003   function! s:is_floating(winid) abort
                                let l:config = nvim_win_get_config(a:winid)
                                return empty(l:config) || !empty(get(l:config, 'relative', ''))
                              endfunction
                            else
                              function! s:is_floating(winid) abort
                                return winheight(a:winid) != -1 && win_id2win(a:winid) == 0
                              endfunction
    1              0.000001 endif
                            
                            "
                            " scroll
                            "
    1              0.000003 function! s:scroll(winid, topline) abort
                              let l:ctx = {}
                              function! l:ctx.callback(winid, topline) abort
                                let l:wininfo = s:info(a:winid)
                                let l:topline = a:topline
                                let l:topline = min([l:topline, line('$') - l:wininfo.height + 1])
                                let l:topline = max([l:topline, 1])
                            
                                if l:topline == l:wininfo.topline
                                  return
                                endif
                            
                                if !has('nvim') && s:is_floating(a:winid)
                                  call popup_setoptions(a:winid, {
                                  \   'firstline': l:topline,
                                  \ })
                                else
                                  let l:delta = l:topline - l:wininfo.topline
                                  let l:key = l:delta > 0 ? "\<C-e>" : "\<C-y>"
                                  execute printf('noautocmd silent normal! %s', repeat(l:key, abs(l:delta)))
                                endif
                              endfunction
                              call s:do(a:winid, { -> l:ctx.callback(a:winid, a:topline) })
                            endfunction
                            
                            "
                            " screenpos
                            "
                            " @param {[number, number]} pos - position on the current buffer.
                            "
    1              0.000003 function! s:screenpos(pos) abort
                              let l:y = a:pos[0]
                              let l:x = a:pos[1] + get(a:pos, 2, 0)
                            
                              let l:view = winsaveview()
                              let l:scroll_x = l:view.leftcol
                              let l:scroll_y = l:view.topline
                            
                              let l:winpos = win_screenpos(win_getid())
                              let l:y = l:winpos[0] + l:y - l:scroll_y
                              let l:x = l:winpos[1] + l:x - l:scroll_x
                              return [l:y, l:x + (wincol() - virtcol('.')) - 1]
                            endfunction
                            
                            "
                            " _get_visible_popup_winids
                            "
    1              0.000003 function! s:_get_visible_popup_winids() abort
                              if !exists('*popup_list')
                                return []
                              endif
                              return filter(popup_list(), 'popup_getpos(v:val).visible')
                            endfunction
                            

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe.vim
Sourced 1 time
Total time:   0.000448
 Self time:   0.000448

count  total (s)   self (s)
    1              0.000020 let s:_plugin_name = expand('<sfile>:t:r')
                            
    1              0.000009 function! vital#{s:_plugin_name}#new() abort
                              return vital#{s:_plugin_name[1:]}#new()
                            endfunction
                            
    1              0.000006 function! vital#{s:_plugin_name}#function(funcname) abort
                              silent! return function(a:funcname)
                            endfunction

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/compe/confirmation.vim
Sourced 1 time
Total time:   0.013045
 Self time:   0.001313

count  total (s)   self (s)
    1   0.001531   0.000037 let s:Position = vital#compe#import('VS.LSP.Position')
    1   0.007055   0.000021 let s:TextEdit = vital#compe#import('VS.LSP.TextEdit')
    1   0.003229   0.000025 let s:CompletionItem = vital#compe#import('VS.LSP.CompletionItem')
                            
                            "
                            " compe#confirmation#lsp
                            "
    1              0.000004 function! compe#confirmation#lsp(args) abort
                              let l:current_line = getline('.')
                              let l:completed_item = a:args.completed_item
                              let l:completion_item = a:args.completion_item
                              let l:suggest_position = { 'line': line('.') - 1, 'character': strchars(strpart(l:current_line, 0, l:completed_item.suggest_offset - 1)) }
                              let l:current_position = s:Position.cursor()
                              let l:request_position = a:args.request_position
                              let l:ExpandSnippet = compe#confirmation#get_expand_snippet()
                              if empty(l:ExpandSnippet)
                                let l:ExpandSnippet = function('s:simple_expand_snippet')
                              endif
                              call s:CompletionItem.confirm({
                              \   'suggest_position': l:suggest_position,
                              \   'request_position': s:min(l:request_position, l:current_position),
                              \   'current_position': l:current_position,
                              \   'current_line': getline('.'),
                              \   'completion_item': l:completion_item,
                              \   'expand_snippet': l:ExpandSnippet,
                              \ })
                            endfunction
                            
                            "
                            " compe#confirmation#get_expand_snippet
                            "
    1              0.000003 function! compe#confirmation#get_expand_snippet() abort
                              if exists('g:loaded_vsnip')
                                return { args -> vsnip#anonymous(args.body) }
                              elseif luaeval('pcall(require, "snippets")')
                                return { args -> luaeval('require"snippets".expand_at_cursor((require"snippets".u.match_indentation(_A)))', args.body) }
                              elseif luaeval('pcall(require, "luasnip")')
                              	return { args -> luaeval('require"luasnip".lsp_expand(_A)', args.body)}
                              elseif exists('g:did_plugin_ultisnips')
                              	return { args -> UltiSnips#Anon(args.body) }
                              endif
                              return v:null
                            endfunction
                            
                            "
                            " simple_expand_snippet
                            "
    1              0.000003 function! s:simple_expand_snippet(args) abort
                              let l:body = substitute(a:args.body, '\$\d\|\${[^}]*}\|\$\w\+', '', 'g')
                              let l:current_position = s:Position.cursor()
                              call s:TextEdit.apply('%', [{
                              \   'range': {
                              \     'start': l:current_position,
                              \     'end': l:current_position,
                              \   },
                              \   'newText': l:body,
                              \ }])
                            endfunction
                            
                            "
                            " return minimum position
                            "
    1              0.000003 function! s:min(pos1, pos2) abort
                              if a:pos1.line < a:pos2.line
                                return a:pos1
                              elseif a:pos1.line == a:pos2.line
                                if a:pos1.character < a:pos2.character
                                  return a:pos1
                                endif
                              endif
                              return a:pos2
                            endfunction

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Position.vim
Sourced 1 time
Total time:   0.000587
 Self time:   0.000545

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000010 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000095   0.000053 execute join(['function! vital#_compe#VS#LSP#Position#import() abort', printf("return map({'cursor': '', 'vim_to_lsp': '', 'lsp_to_vim': ''}, \"vital#_compe#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000007 delfunction s:_SID
                            " ___vital___
                            "
                            " cursor
                            "
    1              0.000003 function! s:cursor() abort
                              return s:vim_to_lsp('%', getpos('.')[1 : 3])
                            endfunction
                            
                            "
                            " vim_to_lsp
                            "
    1              0.000004 function! s:vim_to_lsp(expr, pos) abort
                              let l:line = s:_get_buffer_line(a:expr, a:pos[0])
                              if l:line is v:null
                                return {
                                \   'line': a:pos[0] - 1,
                                \   'character': a:pos[1] - 1
                                \ }
                              endif
                            
                              return {
                              \   'line': a:pos[0] - 1,
                              \   'character': strchars(strpart(l:line, 0, a:pos[1] - 1))
                              \ }
                            endfunction
                            
                            "
                            " lsp_to_vim
                            "
    1              0.000003 function! s:lsp_to_vim(expr, position) abort
                              let l:line = s:_get_buffer_line(a:expr, a:position.line + 1)
                              if l:line is v:null
                                return [a:position.line + 1, a:position.character + 1]
                              endif
                              return [a:position.line + 1, byteidx(l:line, a:position.character) + 1]
                            endfunction
                            
                            "
                            " _get_buffer_line
                            "
    1              0.000003 function! s:_get_buffer_line(expr, lnum) abort
                              try
                                let l:expr = bufnr(a:expr)
                              catch /.*/
                                let l:expr = a:expr
                              endtry
                              if bufloaded(l:expr)
                                return get(getbufline(l:expr, a:lnum), 0, v:null)
                              elseif filereadable(a:expr)
                                return get(readfile(a:expr, '', a:lnum), 0, v:null)
                              endif
                              return v:null
                            endfunction
                            

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim
Sourced 1 time
Total time:   0.001163
 Self time:   0.001133

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000010 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000084   0.000053 execute join(['function! vital#_compe#VS#LSP#TextEdit#import() abort', printf("return map({'_vital_depends': '', 'apply': '', '_vital_loaded': ''}, \"vital#_compe#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000006 delfunction s:_SID
                            " ___vital___
                            "
                            " _vital_loaded
                            "
    1              0.000003 function! s:_vital_loaded(V) abort
                              let s:Text = a:V.import('VS.LSP.Text')
                              let s:Position = a:V.import('VS.LSP.Position')
                              let s:Buffer = a:V.import('VS.Vim.Buffer')
                              let s:Option = a:V.import('VS.Vim.Option')
                            endfunction
                            
                            "
                            " _vital_depends
                            "
    1              0.000002 function! s:_vital_depends() abort
                              return ['VS.LSP.Text', 'VS.LSP.Position', 'VS.Vim.Buffer', 'VS.Vim.Option']
                            endfunction
                            
                            "
                            " apply
                            "
    1              0.000003 function! s:apply(path, text_edits) abort
                              let l:current_bufname = bufname('%')
                              let l:current_position = s:Position.cursor()
                            
                              let l:target_bufnr = s:_switch(a:path)
                              call s:_substitute(l:target_bufnr, a:text_edits, l:current_position)
                              let l:current_bufnr = s:_switch(l:current_bufname)
                            
                              if l:current_bufnr == l:target_bufnr
                                call cursor(s:Position.lsp_to_vim('%', l:current_position))
                              endif
                            endfunction
                            
                            "
                            " _substitute
                            "
    1              0.000004 function! s:_substitute(bufnr, text_edits, current_position) abort
                              try
                                " Save state.
                                let l:Restore = s:Option.define({
                                \   'foldenable': '0',
                                \ })
                                let l:view = winsaveview()
                            
                                " Apply substitute.
                                let [l:fixeol, l:text_edits] = s:_normalize(a:bufnr, a:text_edits)
                                for l:text_edit in l:text_edits
                                  let l:start = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.start)
                                  let l:end = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.end)
                                  let l:text = s:Text.normalize_eol(l:text_edit.newText)
                                  execute printf('noautocmd keeppatterns keepjumps silent %ssubstitute/\%%%sl\%%%sc\_.\{-}\%%%sl\%%%sc/\=l:text/%se',
                                  \   l:start[0],
                                  \   l:start[0],
                                  \   l:start[1],
                                  \   l:end[0],
                                  \   l:end[1],
                                  \   &gdefault ? 'g' : ''
                                  \ )
                                  call s:_fix_cursor_position(a:current_position, l:text_edit, s:Text.split_by_eol(l:text))
                                endfor
                            
                                " Remove last empty line if fixeol enabled.
                                if l:fixeol && getline('$') ==# ''
                                  noautocmd keeppatterns keepjumps silent $delete _
                                endif
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                              finally
                                " Restore state.
                                call l:Restore()
                                call winrestview(l:view)
                              endtry
                            endfunction
                            
                            "
                            " _fix_cursor_position
                            "
    1              0.000004 function! s:_fix_cursor_position(position, text_edit, lines) abort
                              let l:lines_len = len(a:lines)
                              let l:range_len = (a:text_edit.range.end.line - a:text_edit.range.start.line) + 1
                            
                              if a:text_edit.range.end.line < a:position.line
                                let a:position.line += l:lines_len - l:range_len
                              elseif a:text_edit.range.end.line == a:position.line && a:text_edit.range.end.character <= a:position.character
                                let a:position.line += l:lines_len - l:range_len
                                let a:position.character = strchars(a:lines[-1]) + (a:position.character - a:text_edit.range.end.character)
                                if l:lines_len == 1
                                  let a:position.character += a:text_edit.range.start.character
                                endif
                              endif
                            endfunction
                            
                            "
                            " _normalize
                            "
    1              0.000003 function! s:_normalize(bufnr, text_edits) abort
                              let l:text_edits = type(a:text_edits) == type([]) ? a:text_edits : [a:text_edits]
                              let l:text_edits = s:_range(l:text_edits)
                              let l:text_edits = sort(l:text_edits, function('s:_compare'))
                              let l:text_edits = reverse(l:text_edits)
                              return s:_fix_text_edits(a:bufnr, l:text_edits)
                            endfunction
                            
                            "
                            " _range
                            "
    1              0.000002 function! s:_range(text_edits) abort
                              let l:text_edits = []
                              for l:text_edit in a:text_edits
                                if type(l:text_edit) != type({})
                                  continue
                                endif
                                if l:text_edit.range.start.line > l:text_edit.range.end.line || (
                                \   l:text_edit.range.start.line == l:text_edit.range.end.line &&
                                \   l:text_edit.range.start.character > l:text_edit.range.end.character
                                \ )
                                  let l:text_edit.range = { 'start': l:text_edit.range.end, 'end': l:text_edit.range.start }
                                endif
                                let l:text_edits += [l:text_edit]
                              endfor
                              return l:text_edits
                            endfunction
                            
                            "
                            " _compare
                            "
    1              0.000011 function! s:_compare(text_edit1, text_edit2) abort
                              let l:diff = a:text_edit1.range.start.line - a:text_edit2.range.start.line
                              if l:diff == 0
                                return a:text_edit1.range.start.character - a:text_edit2.range.start.character
                              endif
                              return l:diff
                            endfunction
                            
                            "
                            " _fix_text_edits
                            "
    1              0.000004 function! s:_fix_text_edits(bufnr, text_edits) abort
                              let l:max = s:Buffer.get_line_count(a:bufnr)
                            
                              let l:fixeol = v:false
                              let l:text_edits = []
                              for l:text_edit in a:text_edits
                                if l:max <= l:text_edit.range.start.line
                                  let l:text_edit.range.start.line = l:max - 1
                                  let l:text_edit.range.start.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:text_edit.newText = "\n" . l:text_edit.newText
                                  let l:fixeol = &fixendofline && !&binary
                                endif
                                if l:max <= l:text_edit.range.end.line
                                  let l:text_edit.range.end.line = l:max - 1
                                  let l:text_edit.range.end.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:fixeol = &fixendofline && !&binary
                                endif
                                call add(l:text_edits, l:text_edit)
                              endfor
                            
                              return [l:fixeol, l:text_edits]
                            endfunction
                            
                            "
                            " _switch
                            "
    1              0.000003 function! s:_switch(path) abort
                              let l:curr = bufnr('%')
                              let l:next = bufnr(a:path)
                              if l:next >= 0
                                if l:curr != l:next
                                  execute printf('noautocmd keepalt keepjumps %sbuffer!', bufnr(a:path))
                                endif
                              else
                                execute printf('noautocmd keepalt keepjumps edit! %s', fnameescape(a:path))
                              endif
                              return bufnr('%')
                            endfunction
                            

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Text.vim
Sourced 1 time
Total time:   0.000616
 Self time:   0.000560

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000015 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000152   0.000096 execute join(['function! vital#_compe#VS#LSP#Text#import() abort', printf("return map({'normalize_eol': '', 'split_by_eol': ''}, \"vital#_compe#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000012 delfunction s:_SID
                            " ___vital___
                            "
                            " normalize_eol
                            "
    1              0.000006 function! s:normalize_eol(text) abort
                              return substitute(a:text, "\r\n\\|\r", "\n", 'g')
                            endfunction
                            
                            "
                            " split_by_eol
                            "
    1              0.000004 function! s:split_by_eol(text) abort
                              return split(a:text, "\r\n\\|\r\\|\n", v:true)
                            endfunction
                            

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Buffer.vim
Sourced 1 time
Total time:   0.000735
 Self time:   0.000705

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000009 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000080   0.000051 execute join(['function! vital#_compe#VS#Vim#Buffer#import() abort', printf("return map({'get_line_count': '', 'do': '', 'create': '', 'pseudo': '', 'ensure': '', 'load': ''}, \"vital#_compe#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000006 delfunction s:_SID
                            " ___vital___
    1              0.000011 let s:Do = { -> {} }
                            
    1              0.000014 let g:___VS_Vim_Buffer_id = get(g:, '___VS_Vim_Buffer_id', 0)
                            
                            "
                            " get_line_count
                            "
    1              0.000010 if exists('*nvim_buf_line_count')
    1              0.000006   function! s:get_line_count(bufnr) abort
                                return nvim_buf_line_count(a:bufnr)
                              endfunction
                            elseif has('patch-8.2.0019')
                              function! s:get_line_count(bufnr) abort
                                return getbufinfo(a:bufnr)[0].linecount
                              endfunction
                            else
                              function! s:get_line_count(bufnr) abort
                                if bufnr('%') == bufnr(a:bufnr)
                                  return line('$')
                                endif
                                return len(getbufline(a:bufnr, '^', '$'))
                              endfunction
    1              0.000002 endif
                            
                            "
                            " create
                            "
    1              0.000003 function! s:create(...) abort
                              let g:___VS_Vim_Buffer_id += 1
                              let l:bufname = printf('VS.Vim.Buffer: %s: %s',
                              \   g:___VS_Vim_Buffer_id,
                              \   get(a:000, 0, 'VS.Vim.Buffer.Default')
                              \ )
                              return s:load(l:bufname)
                            endfunction
                            
                            "
                            " ensure
                            "
    1              0.000003 function! s:ensure(expr) abort
                              if !bufexists(a:expr)
                                if type(a:expr) == type(0)
                                  throw printf('VS.Vim.Buffer: `%s` is not valid expr.', l:bufnr)
                                endif
                                badd `=a:expr`
                              endif
                              return bufnr(a:expr)
                            endfunction
                            
                            "
                            " load
                            "
    1              0.000005 if exists('*bufload')
    1              0.000003   function! s:load(expr) abort
                                let l:bufnr = s:ensure(a:expr)
                                if !bufloaded(l:bufnr)
                                  call bufload(l:bufnr)
                                endif
                                return l:bufnr
                              endfunction
                            else
                              function! s:load(expr) abort
                                let l:curr_bufnr = bufnr('%')
                                try
                                  let l:bufnr = s:ensure(a:expr)
                                  execute printf('keepalt keepjumps silent %sbuffer', l:bufnr)
                                catch /.*/
                                  echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                                finally
                                  execute printf('noautocmd keepalt keepjumps silent %sbuffer', l:curr_bufnr)
                                endtry
                                return l:bufnr
                              endfunction
    1              0.000001 endif
                            
                            "
                            " do
                            "
    1              0.000003 function! s:do(bufnr, func) abort
                              let l:curr_bufnr = bufnr('%')
                              if l:curr_bufnr == a:bufnr
                                call a:func()
                                return
                              endif
                            
                              try
                                execute printf('noautocmd keepalt keepjumps silent %sbuffer', a:bufnr)
                                call a:func()
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
                              finally
                                execute printf('noautocmd keepalt keepjumps silent %sbuffer', l:curr_bufnr)
                              endtry
                            endfunction
                            
                            "
                            " pseudo
                            "
    1              0.000003 function! s:pseudo(filepath) abort
                              if !filereadable(a:filepath)
                                throw printf('VS.Vim.Buffer: `%s` is not valid filepath.', a:filepath)
                              endif
                            
                              " create pseudo buffer
                              let l:bufname = printf('VSVimBufferPseudo://%s', a:filepath)
                              if bufexists(l:bufname)
                                return s:ensure(l:bufname)
                              endif
                            
                              let l:bufnr = s:ensure(l:bufname)
                              let l:group = printf('VS_Vim_Buffer_pseudo:%s', l:bufnr)
                              execute printf('augroup %s', l:group)
                                execute printf('autocmd BufReadCmd <buffer=%s> call setline(1, readfile(bufname("%")[20 : -1])) | try | filetype detect | catch /.*/ | endtry | augroup %s | autocmd! | augroup END', l:bufnr, l:group)
                              augroup END
                              return l:bufnr
                            endfunction
                            

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Option.vim
Sourced 1 time
Total time:   0.000598
 Self time:   0.000569

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000010 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000078   0.000049 execute join(['function! vital#_compe#VS#Vim#Option#import() abort', printf("return map({'define': ''}, \"vital#_compe#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000006 delfunction s:_SID
                            " ___vital___
                            "
                            " define
                            "
    1              0.000004 function! s:define(map) abort
                              let l:old = {}
                              for [l:key, l:value] in items(a:map)
                                let l:old[l:key] = eval(printf('&%s', l:key))
                                execute printf('let &%s = "%s"', l:key, l:value)
                              endfor
                              return { -> s:define(l:old) }
                            endfunction
                            

SCRIPT  /Users/chip/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/CompletionItem.vim
Sourced 1 time
Total time:   0.001984
 Self time:   0.001946

count  total (s)   self (s)
                            " ___vital___
                            " NOTE: lines between '" ___vital___' is generated by :Vitalize.
                            " Do not modify the code nor insert new lines before '" ___vital___'
    1              0.000014 function! s:_SID() abort
                              return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze__SID$')
                            endfunction
    1   0.000154   0.000115 execute join(['function! vital#_compe#VS#LSP#CompletionItem#import() abort', printf("return map({'_vital_depends': '', 'confirm': '', '_vital_loaded': ''}, \"vital#_compe#function('<SNR>%s_' . v:key)\")", s:_SID()), 'endfunction'], "\n")
    1              0.000009 delfunction s:_SID
                            " ___vital___
                            "
                            " _vital_loaded
                            "
    1              0.000005 function! s:_vital_loaded(V) abort
                              let s:Position = a:V.import('VS.LSP.Position')
                              let s:TextEdit = a:V.import('VS.LSP.TextEdit')
                              let s:Text = a:V.import('VS.LSP.Text')
                            endfunction
                            
                            "
                            " _vital_depends
                            "
    1              0.000003 function! s:_vital_depends() abort
                              return ['VS.LSP.Position', 'VS.LSP.TextEdit', 'VS.LSP.Text']
                            endfunction
                            
                            "
                            " confirm
                            "
                            " @param {LSP.Position}                                                 args.suggest_position
                            " @param {LSP.Position}                                                 args.request_position
                            " @param {LSP.Position}                                                 args.current_position
                            " @param {string}                                                       args.current_line
                            " @param {LSP.CompletionItem}                                           args.completion_item
                            " @param {(args: { body: string; insert_text_mode: number; }) => void?} args.expand_snippet
                            "
                            " # Pre-condition
                            "
                            "   - You must pass `current_position` that represents the position when `CompleteDone` was fired.
                            "   - You must pass `current_line` that represents the line when `CompleteDone` was fired.
                            "   - You must call this function after the commit characters has been inserted.
                            "
                            " # The positoins
                            "
                            "   0. The example case
                            "
                            "     call getbufl|<C-x><C-o><C-n><C-y>   ->   call getbufline|
                            "
                            "   1. suggest_position
                            "
                            "     call |getbufline
                            "
                            "   2. request_position
                            "
                            "     call getbufl|ine
                            "
                            "   3. current_position
                            "
                            "     call getbufline|
                            "
                            "
    1              0.000004 function! s:confirm(args) abort
                              let l:suggest_position = a:args.suggest_position
                              let l:request_position = a:args.request_position
                              let l:current_position = a:args.current_position
                              let l:current_line = a:args.current_line
                              let l:completion_item = a:args.completion_item
                              let l:ExpandSnippet = get(a:args, 'expand_snippet', v:null)
                            
                              " 1. Prepare for alignment to VSCode behavior.
                              let l:expansion = s:_get_expansion({
                              \   'suggest_position': l:suggest_position,
                              \   'request_position': l:request_position,
                              \   'current_position': l:current_position,
                              \   'current_line': l:current_line,
                              \   'completion_item': l:completion_item,
                              \ })
                              if !empty(l:expansion)
                                " Remove commit characters if expansion is needed.
                                if getline('.') !=# l:current_line
                                  call setline(l:current_position.line + 1, l:current_line)
                                  call cursor(s:Position.lsp_to_vim('%', l:current_position))
                                endif
                            
                                " Restore state of the timing when `textDocument/completion` was sent.
                                call s:TextEdit.apply('%', [{
                                \   'range': { 'start': l:request_position, 'end': l:current_position },
                                \   'newText': ''
                                \ }])
                              endif
                            
                              " 2. Apply additionalTextEdits
                              if type(get(l:completion_item, 'additionalTextEdits', v:null)) == type([])
                                call s:TextEdit.apply('%', l:completion_item.additionalTextEdits)
                              endif
                            
                              " 3. Apply expansion
                              if !empty(l:expansion)
                                let l:current_position = s:Position.cursor() " Update current_position to after additionalTextEdits.
                                let l:range = {
                                \   'start': extend({
                                \     'character': l:current_position.character - l:expansion.overflow_before,
                                \   }, l:current_position, 'keep'),
                                \   'end': extend({
                                \     'character': l:current_position.character + l:expansion.overflow_after,
                                \   }, l:current_position, 'keep')
                                \ }
                            
                                " Snippet.
                                if l:expansion.is_snippet && !empty(l:ExpandSnippet)
                                  call s:TextEdit.apply('%', [{ 'range': l:range, 'newText': '' }])
                                  call cursor(s:Position.lsp_to_vim('%', l:range.start))
                                  call l:ExpandSnippet({ 'body': l:expansion.new_text, 'insert_text_mode': get(l:completion_item, 'insertTextMode', 2) })
                            
                                " TextEdit.
                                else
                                  call s:TextEdit.apply('%', [{ 'range': l:range, 'newText': l:expansion.new_text }])
                            
                                  " Move cursor position to end of new_text like as snippet.
                                  let l:lines = s:Text.split_by_eol(l:expansion.new_text)
                                  let l:cursor = copy(l:range.start)
                                  let l:cursor.line += len(l:lines) - 1
                                  let l:cursor.character = strchars(l:lines[-1]) + (len(l:lines) == 1 ? l:cursor.character : 0)
                                  call cursor(s:Position.lsp_to_vim('%', l:cursor))
                                endif
                              endif
                            endfunction
                            
                            "
                            " _get_expansion
                            "
    1              0.000010 function! s:_get_expansion(args) abort
                              let l:current_line = a:args.current_line
                              let l:suggest_position = a:args.suggest_position
                              let l:request_position = a:args.request_position
                              let l:current_position = a:args.current_position
                              let l:completion_item = a:args.completion_item
                            
                              let l:is_snippet = get(l:completion_item, 'insertTextFormat', 1) == 2
                              if type(get(l:completion_item, 'textEdit', v:null)) == type({})
                                let l:inserted_text = strcharpart(l:current_line, l:request_position.character, l:current_position.character - l:request_position.character)
                                let l:overflow_before = l:request_position.character - l:completion_item.textEdit.range.start.character
                                let l:overflow_after = l:completion_item.textEdit.range.end.character - l:request_position.character
                                let l:inserted = ''
                                \   . strcharpart(l:current_line, l:request_position.character - l:overflow_before, l:overflow_before)
                                \   . strcharpart(l:current_line, l:request_position.character, strchars(l:inserted_text) + l:overflow_after)
                                let l:new_text = l:completion_item.textEdit.newText
                                if s:_trim_tabstop(l:new_text) !=# l:inserted
                                  " The LSP spec says `textEdit range must contain the request position.`
                                  return {
                                  \   'overflow_before': max([0, l:overflow_before]),
                                  \   'overflow_after': max([0, l:overflow_after]),
                                  \   'new_text': l:new_text,
                                  \   'is_snippet': l:is_snippet,
                                  \ }
                                endif
                              else
                                let l:inserted = strcharpart(l:current_line, l:suggest_position.character, l:current_position.character - l:suggest_position.character)
                                let l:new_text = get(l:completion_item, 'insertText', v:null)
                                let l:new_text = !empty(l:new_text) ? l:new_text : l:completion_item.label
                                if s:_trim_tabstop(l:new_text) !=# l:inserted
                                  return {
                                  \   'overflow_before': l:request_position.character - l:suggest_position.character,
                                  \   'overflow_after': 0,
                                  \   'new_text': l:new_text,
                                  \   'is_snippet': l:is_snippet,
                                  \ }
                                endif
                              endif
                              return {}
                            endfunction
                            
                            "
                            " _trim_tabstop
                            "
    1              0.000004 function! s:_trim_tabstop(text) abort
                              return substitute(a:text, '\%(\$0\|\${0}\)$', '', 'g')
                            endfunction
                            

FUNCTION  compe#confirmation#get_expand_snippet()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/compe/confirmation.vim:32
Called 1 time
Total time:   0.004724
 Self time:   0.004724

count  total (s)   self (s)
    1              0.000015   if exists('g:loaded_vsnip')
                                return { args -> vsnip#anonymous(args.body) }
    1              0.004627   elseif luaeval('pcall(require, "snippets")')
                                return { args -> luaeval('require"snippets".expand_at_cursor((require"snippets".u.match_indentation(_A)))', args.body) }
    1              0.000036   elseif luaeval('pcall(require, "luasnip")')
    1              0.000015   	return { args -> luaeval('require"luasnip".lsp_expand(_A)', args.body)}
                              elseif exists('g:did_plugin_ultisnips')
                              	return { args -> UltiSnips#Anon(args.body) }
                              endif
                              return v:null

FUNCTION  <SNR>8_SynSet()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/syntax/synload.vim:33
Called 1 time
Total time:   0.019392
 Self time:   0.003494

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    1              0.000004   syn clear
    1              0.000003   if exists("b:current_syntax")
                                unlet b:current_syntax
    1              0.000001   endif
                            
    1              0.000003   let s = expand("<amatch>")
    1              0.000002   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    1              0.000001   elseif s == "OFF"
                                let s = ""
    1              0.000000   endif
                            
    1              0.000001   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    2              0.000009     for name in split(s, '\.')
    1              0.000002       if !empty(name)
    1   0.018367   0.002470         exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    1              0.000973         exe "runtime! syntax/" . name . ".lua syntax/" . name . "/*.lua"
    1              0.000002       endif
    2              0.000002     endfor
    1              0.000001   endif

FUNCTION  <SNR>48_normalize()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/compe.vim:113
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000008   if type(a:option) == v:t_string
    1              0.000007     return { 'keys': a:option, 'mode': 'n' }
                              endif
                              return a:option

FUNCTION  GetClojureIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/indent/clojure.vim:357
Called 1 time
Total time:   0.000155
 Self time:   0.000133

count  total (s)   self (s)
    1              0.000025 		let lnum = line('.')
    1              0.000006 		let orig_lnum = lnum
    1              0.000008 		let orig_col = col('.')
    1   0.000063   0.000041 		let [opening_lnum, indent] = s:clojure_indent_pos()
                            
                            		" Account for multibyte characters
    1              0.000004 		if opening_lnum > 0
                            			let indent -= indent - virtcol([opening_lnum, indent])
    1              0.000003 		endif
                            
                            		" Return if there are no previous lines to inherit from
    1              0.000005 		if opening_lnum < 1 || opening_lnum >= lnum - 1
    1              0.000012 			call cursor(orig_lnum, orig_col)
    1              0.000003 			return indent
                            		endif
                            
                            		let bracket_count = 0
                            
                            		" Take the indent of the first previous non-white line that is
                            		" at the same sexp level. cf. src/misc1.c:get_lisp_indent()
                            		while 1
                            			let lnum = prevnonblank(lnum - 1)
                            			let col = 1
                            
                            			if lnum <= opening_lnum
                            				break
                            			endif
                            
                            			call cursor(lnum, col)
                            
                            			" Handle bracket counting edge case
                            			if s:is_paren()
                            				let bracket_count += s:bracket_type(s:current_char())
                            			endif
                            
                            			while 1
                            				if search('\v[(\[{}\])]', '', lnum) < 1
                            					break
                            				elseif !s:ignored_region()
                            					let bracket_count += s:bracket_type(s:current_char())
                            				endif
                            			endwhile
                            
                            			if bracket_count == 0
                            				" Check if this is part of a multiline string
                            				call cursor(lnum, 1)
                            				if s:syn_id_name() !~? '\vstring|regex'
                            					call cursor(orig_lnum, orig_col)
                            					return indent(lnum)
                            				endif
                            			endif
                            		endwhile
                            
                            		call cursor(orig_lnum, orig_col)
                            		return indent

FUNCTION  <SNR>23_MRU_Refresh_Menu()
    Defined: ~/.local/share/nvim/plugged/mru/plugin/mru.vim:876
Called 2 times
Total time:   0.004181
 Self time:   0.000594

count  total (s)   self (s)
    2              0.000015   if !has('menu') || !g:MRU_Add_Menu
                                " No support for menus
                                return
    2              0.000002   endif
                            
                              " Setup the cpoptions properly for the maps to work
    2              0.000010   let old_cpoptions = &cpoptions
    2              0.000027   set cpoptions&vim
                            
                              " Remove the MRU menu
                              " To retain the teared-off MRU menu, we need to add a dummy entry
    2              0.000031   silent! unmenu &File.&Recent\ Files
                              " The menu priority of the File menu is 10. If the MRU plugin runs
                              " first before menu.vim, the File menu order may not be correct.
                              " So specify the priority of the File menu here.
    2              0.000023   10noremenu &File.&Recent\ Files.Dummy <Nop>
    2              0.000058   silent! unmenu! &File.&Recent\ Files
                            
    2              0.000074   anoremenu <silent> &File.&Recent\ Files.Refresh\ list :call <SID>MRU_LoadList()<CR>
    2   0.000105   0.000070   exe 'tmenu File.&Recent\ Files.Refresh\ list Reload the MRU file list from ' . s:MRU_escape_filename(s:MRU_File)
    2              0.000019   anoremenu File.&Recent\ Files.-SEP1-           :
                            
                              " Add the filenames in the MRU list to the menu
    2              0.000012   let entry_cnt = len(s:MRU_files)
    2              0.000006   if entry_cnt > g:MRU_Max_Menu_Entries
                                " Show only MRU_Max_Menu_Entries file names in the menu
    2              0.000022     let mru_list = s:MRU_files[0 : g:MRU_Max_Menu_Entries - 1]
    2              0.000006     let entry_cnt = g:MRU_Max_Menu_Entries
                              else
                                let mru_list = s:MRU_files
    2              0.000002   endif
    2              0.000006   if entry_cnt > g:MRU_Max_Submenu_Entries
                                " Split the MRU menu into sub-menus
                                for start_idx in range(0, entry_cnt, g:MRU_Max_Submenu_Entries)
                                  let last_idx = start_idx + g:MRU_Max_Submenu_Entries - 1
                                  if last_idx >= entry_cnt
                            	let last_idx = entry_cnt - 1
                                  endif
                                  let prefix = 'Files\ (' . (start_idx + 1) . '\.\.\.' . (last_idx + 1) . ').'
                                  call s:MRU_add_files_to_menu(prefix, mru_list[start_idx : last_idx])
                                endfor
    2              0.000003   else
    2   0.003595   0.000044     call s:MRU_add_files_to_menu('', mru_list)
    2              0.000002   endif
                            
                              " Remove the dummy menu entry
    2              0.000017   unmenu &File.&Recent\ Files.Dummy
                            
                              " Restore the previous cpoptions settings
    2              0.000020   let &cpoptions = old_cpoptions

FUNCTION  vital#_compe#VS#Vim#Option#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Option.vim:7
Called 1 time
Total time:   0.000057
 Self time:   0.000043

count  total (s)   self (s)
    1   0.000055   0.000041 return map({'define': ''}, "vital#_compe#function('<SNR>57_' . v:key)")

FUNCTION  <SNR>56_get_line_count()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Buffer.vim:18
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000023     return nvim_buf_line_count(a:bufnr)

FUNCTION  <SNR>52_min()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/compe/confirmation.vim:63
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    1              0.000006   if a:pos1.line < a:pos2.line
                                return a:pos1
    1              0.000003   elseif a:pos1.line == a:pos2.line
    1              0.000003     if a:pos1.character < a:pos2.character
    1              0.000002       return a:pos1
                                endif
                              endif
                              return a:pos2

FUNCTION  vital#_compe#VS#LSP#CompletionItem#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/CompletionItem.vim:7
Called 1 time
Total time:   0.000109
 Self time:   0.000078

count  total (s)   self (s)
    1   0.000107   0.000077 return map({'_vital_depends': '', 'confirm': '', '_vital_loaded': ''}, "vital#_compe#function('<SNR>58_' . v:key)")

FUNCTION  <SNR>23_MRU_AddFile()
    Defined: ~/.local/share/nvim/plugged/mru/plugin/mru.vim:179
Called 3 times
Total time:   0.005915
 Self time:   0.000955

count  total (s)   self (s)
    3              0.000008   if s:mru_list_locked
                                " MRU list is currently locked
                                return
    3              0.000003   endif
                            
                              " Get the full path to the filename
    3              0.000255   let fname = fnamemodify(bufname(a:acmd_bufnr + 0), ':p')
    3              0.000009   if fname == ''
                                return
    3              0.000002   endif
                            
                              " Skip temporary buffers with buftype set. The buftype is set for buffers
                              " used by plugins.
    3              0.000010   if &buftype != ''
    1              0.000001     return
    2              0.000001   endif
                            
    2              0.000005   if g:MRU_Include_Files != ''
                                " If MRU_Include_Files is set, include only files matching the
                                " specified pattern
                                if fname !~# g:MRU_Include_Files
                                  return
                                endif
    2              0.000001   endif
                            
    2              0.000004   if g:MRU_Exclude_Files != ''
                                " Do not add files matching the pattern specified in the
                                " MRU_Exclude_Files to the MRU list
                                if fname =~# g:MRU_Exclude_Files
                                  return
                                endif
    2              0.000001   endif
                            
                              " If the filename is not already present in the MRU list and is not
                              " readable then ignore it
    2              0.000012   let idx = index(s:MRU_files, fname)
    2              0.000003   if idx == -1
    1              0.000007     if !filereadable(fname)
                                  " File is not readable and is not in the MRU list
    1              0.000001       return
                                endif
    1              0.000001   endif
                            
                              " Load the latest MRU file list
    1   0.002529   0.000117   call s:MRU_LoadList()
                            
                              " Remove the new file name from the existing MRU list (if already present)
    1              0.000128   call filter(s:MRU_files, 'v:val !=# fname')
                            
                              " Add the new file list to the beginning of the updated old file list
    1              0.000005   call insert(s:MRU_files, fname, 0)
                            
                              " Trim the list
    1              0.000005   if len(s:MRU_files) > g:MRU_Max_Entries
                                call remove(s:MRU_files, g:MRU_Max_Entries, -1)
    1              0.000001   endif
                            
                              " Save the updated MRU list
    1   0.000487   0.000043   call s:MRU_SaveList()
                            
                              " Refresh the MRU menu
    1   0.002130   0.000026   call s:MRU_Refresh_Menu()
                            
                              " If the MRU window is open, update the displayed MRU list
    1              0.000004   let bname = s:MRU_buf_name
    1              0.000197   let winnum = bufwinnr(bname)
    1              0.000003   if winnum != -1
                                let cur_winnr = winnr()
                                call s:MRU_Open_Window('', '', 0)
                                if winnr() != cur_winnr
                                  exe cur_winnr . 'wincmd w'
                                endif
    1              0.000001   endif

FUNCTION  <SNR>18_on_insert_enter()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/plugin/compe.vim:25
Called 1 time
Total time:   0.002942
 Self time:   0.002942

count  total (s)   self (s)
    1              0.002940   call luaeval('require"compe"._on_insert_enter()')

FUNCTION  <SNR>58__get_expansion()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/CompletionItem.vim:131
Called 1 time
Total time:   0.000186
 Self time:   0.000162

count  total (s)   self (s)
    1              0.000005   let l:current_line = a:args.current_line
    1              0.000004   let l:suggest_position = a:args.suggest_position
    1              0.000003   let l:request_position = a:args.request_position
    1              0.000003   let l:current_position = a:args.current_position
    1              0.000003   let l:completion_item = a:args.completion_item
                            
    1              0.000008   let l:is_snippet = get(l:completion_item, 'insertTextFormat', 1) == 2
    1              0.000011   if type(get(l:completion_item, 'textEdit', v:null)) == type({})
                                let l:inserted_text = strcharpart(l:current_line, l:request_position.character, l:current_position.character - l:request_position.character)
                                let l:overflow_before = l:request_position.character - l:completion_item.textEdit.range.start.character
                                let l:overflow_after = l:completion_item.textEdit.range.end.character - l:request_position.character
                                let l:inserted = ''   . strcharpart(l:current_line, l:request_position.character - l:overflow_before, l:overflow_before)   . strcharpart(l:current_line, l:request_position.character, strchars(l:inserted_text) + l:overflow_after)
                                let l:new_text = l:completion_item.textEdit.newText
                                if s:_trim_tabstop(l:new_text) !=# l:inserted
                                  " The LSP spec says `textEdit range must contain the request position.`
                                  return {   'overflow_before': max([0, l:overflow_before]),   'overflow_after': max([0, l:overflow_after]),   'new_text': l:new_text,   'is_snippet': l:is_snippet, }
                                endif
    1              0.000001   else
    1              0.000011     let l:inserted = strcharpart(l:current_line, l:suggest_position.character, l:current_position.character - l:suggest_position.character)
    1              0.000007     let l:new_text = get(l:completion_item, 'insertText', v:null)
    1              0.000008     let l:new_text = !empty(l:new_text) ? l:new_text : l:completion_item.label
    1   0.000047   0.000022     if s:_trim_tabstop(l:new_text) !=# l:inserted
    1              0.000013       return {   'overflow_before': l:request_position.character - l:suggest_position.character,   'overflow_after': 0,   'new_text': l:new_text,   'is_snippet': l:is_snippet, }
                                endif
                              endif
                              return {}

FUNCTION  <SNR>5_LoadFTPlugin()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/ftplugin.vim:14
Called 1 time
Total time:   0.008621
 Self time:   0.008218

count  total (s)   self (s)
    1              0.000009     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    1              0.000001     endif
                            
    1              0.000005     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000011       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    2              0.000012       for name in split(s, '\.')
    1   0.004594   0.004190         exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                    " Load lua ftplugins
    1              0.003952         exe printf('runtime! ftplugin/%s.lua ftplugin/%s_*.lua ftplugin/%s/*.lua', name, name, name)
    2              0.000007       endfor
    1              0.000001     endif

FUNCTION  <SNR>40_clojure_indent_pos()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/indent/clojure.vim:229
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                            		" Get rid of special case.
    1              0.000010 		if line(".") == 1
    1              0.000006 			return [0, 0]
                            		endif
                            
                            		" We have to apply some heuristics here to figure out, whether to use
                            		" normal lisp indenting or not.
                            		let i = s:check_for_string()
                            		if i > -1
                            			return [0, i + !!g:clojure_align_multiline_strings]
                            		endif
                            
                            		call cursor(0, 1)
                            
                            		" Find the next enclosing [ or {. We can limit the second search
                            		" to the line, where the [ was found. If no [ was there this is
                            		" zero and we search for an enclosing {.
                            		let paren = s:match_pairs('(', ')', 0)
                            		let bracket = s:match_pairs('\[', '\]', paren[0])
                            		let curly = s:match_pairs('{', '}', bracket[0])
                            
                            		" In case the curly brace is on a line later then the [ or - in
                            		" case they are on the same line - in a higher column, we take the
                            		" curly indent.
                            		if curly[0] > bracket[0] || curly[1] > bracket[1]
                            			if curly[0] > paren[0] || curly[1] > paren[1]
                            				return curly
                            			endif
                            		endif
                            
                            		" If the curly was not chosen, we take the bracket indent - if
                            		" there was one.
                            		if bracket[0] > paren[0] || bracket[1] > paren[1]
                            			return bracket
                            		endif
                            
                            		" There are neither { nor [ nor (, ie. we are at the toplevel.
                            		if paren == [0, 0]
                            			return paren
                            		endif
                            
                            		" Now we have to reimplement lispindent. This is surprisingly easy, as
                            		" soon as one has access to syntax items.
                            		"
                            		" - Check whether we are in a special position after a word in
                            		"   g:clojure_special_indent_words. These are special cases.
                            		" - Get the next keyword after the (.
                            		" - If its first character is also a (, we have another sexp and align
                            		"   one column to the right of the unmatched (.
                            		" - In case it is in lispwords, we indent the next line to the column of
                            		"   the ( + sw.
                            		" - If not, we check whether it is last word in the line. In that case
                            		"   we again use ( + sw for indent.
                            		" - In any other case we use the column of the end of the word + 2.
                            		call cursor(paren)
                            
                            		if s:is_method_special_case(paren)
                            			return [paren[0], paren[1] + &shiftwidth - 1]
                            		endif
                            
                            		if s:is_reader_conditional_special_case(paren)
                            			return paren
                            		endif
                            
                            		" In case we are at the last character, we use the paren position.
                            		if col("$") - 1 == paren[1]
                            			return paren
                            		endif
                            
                            		" In case after the paren is a whitespace, we search for the next word.
                            		call cursor(0, col('.') + 1)
                            		if s:current_char() == ' '
                            			call search('\v\S', 'W')
                            		endif
                            
                            		" If we moved to another line, there is no word after the (. We
                            		" use the ( position for indent.
                            		if line(".") > paren[0]
                            			return paren
                            		endif
                            
                            		" We still have to check, whether the keyword starts with a (, [ or {.
                            		" In that case we use the ( position for indent.
                            		let w = s:current_word()
                            		if s:bracket_type(w[0]) == 1
                            			return paren
                            		endif
                            
                            		" If the keyword begins with #, check if it is an anonymous
                            		" function or set, in which case we indent by the shiftwidth
                            		" (minus one if g:clojure_align_subforms = 1), or if it is
                            		" ignored, in which case we use the ( position for indent.
                            		if w[0] == "#"
                            			" TODO: Handle #=() and other rare reader invocations?
                            			if w[1] == '(' || w[1] == '{'
                            				return [paren[0], paren[1] + (g:clojure_align_subforms ? 0 : &shiftwidth - 1)]
                            			elseif w[1] == '_'
                            				return paren
                            			endif
                            		endif
                            
                            		" Test words without namespace qualifiers and leading reader macro
                            		" metacharacters.
                            		"
                            		" e.g. clojure.core/defn and #'defn should both indent like defn.
                            		let ww = s:strip_namespace_and_macro_chars(w)
                            
                            		if &lispwords =~# '\V\<' . ww . '\>'
                            			return [paren[0], paren[1] + &shiftwidth - 1]
                            		endif
                            
                            		if g:clojure_fuzzy_indent && !s:match_one(g:clojure_fuzzy_indent_blacklist, ww) && s:match_one(g:clojure_fuzzy_indent_patterns, ww)
                            			return [paren[0], paren[1] + &shiftwidth - 1]
                            		endif
                            
                            		call search('\v\_s', 'cW')
                            		call search('\v\S', 'W')
                            		if paren[0] < line(".")
                            			return [paren[0], paren[1] + (g:clojure_align_subforms ? 0 : &shiftwidth - 1)]
                            		endif
                            
                            		call search('\v\S', 'bW')
                            		return [line('.'), col('.') + 1]

FUNCTION  <SNR>54__switch()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:173
Called 4 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
    4              0.000024   let l:curr = bufnr('%')
    4              0.000042   let l:next = bufnr(a:path)
    4              0.000010   if l:next >= 0
    4              0.000010     if l:curr != l:next
                                  execute printf('noautocmd keepalt keepjumps %sbuffer!', bufnr(a:path))
    4              0.000005     endif
                              else
                                execute printf('noautocmd keepalt keepjumps edit! %s', fnameescape(a:path))
    4              0.000004   endif
    4              0.000015   return bufnr('%')

FUNCTION  vital#_compe#VS#LSP#TextEdit#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:7
Called 1 time
Total time:   0.000086
 Self time:   0.000061

count  total (s)   self (s)
    1   0.000084   0.000059 return map({'_vital_depends': '', 'apply': '', '_vital_loaded': ''}, "vital#_compe#function('<SNR>54_' . v:key)")

FUNCTION  <SNR>49_import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:38
Called 11 times
Total time:   0.019132
 Self time:   0.000794

count  total (s)   self (s)
   11              0.000035   let target = {}
   11              0.000027   let functions = []
   11              0.000039   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
   11              0.000034   endfor
   11   0.013324   0.005054   let module = self._import(a:name)
   11              0.000040   if empty(functions)
   11              0.000143     call extend(target, module, 'keep')
                              else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
   11              0.000011   endif
   11              0.000017   return target

FUNCTION  <SNR>23_MRU_add_files_to_menu()
    Defined: ~/.local/share/nvim/plugged/mru/plugin/mru.vim:834
Called 2 times
Total time:   0.003551
 Self time:   0.003337

count  total (s)   self (s)
   22              0.000050   for fname in a:file_list
                                " Escape special characters in the filename
   20              0.000206     let esc_fname = escape(fnamemodify(fname, ':t'), ".\\" . s:esc_filename_chars)
   20              0.000169     let esc_fname = substitute(esc_fname, '&', '&&', 'g')
                            
                                " Truncate the directory name if it is long
   20              0.000102     let dir_name = fnamemodify(fname, ':h')
   20              0.000071     if v:version >= 800 || has("patch-7.4.1730")
   20              0.000087       let len = strchars(dir_name)
                                  " Shorten long file names by adding only few characters from
                                  " the beginning and end.
   20              0.000029       if len > 30
    8              0.000088 	let dir_name = strcharpart(dir_name, 0, 10) . '...' . strcharpart(dir_name, len - 20)
   20              0.000021       endif
                                else
                                  let len = strlen(dir_name)
                                  " Shorten long file names by adding only few characters from
                                  " the beginning and end.
                                  if len > 30
                            	let dir_name = strpart(dir_name, 0, 10) . '...' . strpart(dir_name, len - 20)
                                  endif
   20              0.000016     endif
   20              0.000148     let esc_dir_name = escape(dir_name, ".\\" . s:esc_filename_chars)
   20              0.000156     let esc_dir_name = substitute(esc_dir_name, '&', '&&', 'g')
                            
   20              0.000166     let menu_path = '&File.&Recent\ Files.' . a:prefix . esc_fname . '\ (' . esc_dir_name . ')'
   20   0.000575   0.000361     let esc_mfname = s:MRU_escape_filename(fname)
   20              0.000611     exe 'anoremenu <silent> ' . menu_path . " :call <SID>MRU_Edit_File('" . esc_mfname . "', 1)<CR>"
   20              0.000445     exe 'tmenu ' . menu_path . ' Edit file ' . esc_mfname
   22              0.000039   endfor

FUNCTION  compe#confirm()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/compe.vim:45
Called 1 time
Total time:   0.000652
 Self time:   0.000634

count  total (s)   self (s)
    1              0.000036   let l:completeopts = split(&completeopt, ',')
    3              0.000016   for l:opt in ['menuone', 'noselect']
    2              0.000016     if index(l:completeopts, l:opt) == -1
                                  echohl ErrorMsg
                                  echomsg '[nvim-compe] You must set `set completeopt=menuone,noselect` in your vimrc.'
                                  echohl None
    2              0.000003     endif
    3              0.000007   endfor
                            
    1   0.000092   0.000073   let l:option = s:normalize(get(a:000, 0, {}))
    1              0.000012   let l:index = complete_info(['selected']).selected
    1              0.000007   let l:select = get(l:option, 'select', v:false)
    1              0.000004   let l:selected = l:index != -1
    1              0.000011   if mode()[0] ==# 'i' && pumvisible() && (l:select || l:selected)
    1              0.000352     let l:info = luaeval('require"compe"._confirm_pre(_A)', (l:selected ? l:index + 1 : 1))
    1              0.000006     if !empty(l:info)
    1              0.000029       call feedkeys(repeat("\<BS>", strchars(getline('.')[l:info.offset - 1 : col('.') - 2], 1)), 'n')
    1              0.000008       call feedkeys(l:info.item.word, 'n')
    1              0.000009       call feedkeys("\<Plug>(compe-confirm)", '')
                                else
                                  return "\<C-y>" " fallback for other plugin's completion menu
    1              0.000001     endif
    1              0.000004     return "\<Ignore>"
                              endif
                              return s:fallback(l:option)

FUNCTION  <SNR>53_lsp_to_vim()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Position.vim:38
Called 7 times
Total time:   0.000480
 Self time:   0.000276

count  total (s)   self (s)
    7   0.000347   0.000143   let l:line = s:_get_buffer_line(a:expr, a:position.line + 1)
    7              0.000022   if l:line is v:null
                                return [a:position.line + 1, a:position.character + 1]
    7              0.000009   endif
    7              0.000060   return [a:position.line + 1, byteidx(l:line, a:position.character) + 1]

FUNCTION  <SNR>54__range()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:116
Called 2 times
Total time:   0.000171
 Self time:   0.000171

count  total (s)   self (s)
    2              0.000006   let l:text_edits = []
    4              0.000013   for l:text_edit in a:text_edits
    2              0.000015     if type(l:text_edit) != type({})
                                  continue
    2              0.000003     endif
    2              0.000023     if l:text_edit.range.start.line > l:text_edit.range.end.line || (   l:text_edit.range.start.line == l:text_edit.range.end.line &&   l:text_edit.range.start.character > l:text_edit.range.end.character )
                                  let l:text_edit.range = { 'start': l:text_edit.range.end, 'end': l:text_edit.range.start }
    2              0.000003     endif
    2              0.000014     let l:text_edits += [l:text_edit]
    4              0.000012   endfor
    2              0.000006   return l:text_edits

FUNCTION  <SNR>49__import_func_name()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:238
Called 7 times
Total time:   0.000270
 Self time:   0.000150

count  total (s)   self (s)
    7   0.000264   0.000144   return printf('vital#_%s#%s#import', a:plugin_name, s:_dot_to_sharp(a:module_name))

FUNCTION  compe#_is_selected_manually()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/compe.vim:99
Called 26 times
Total time:   0.000292
 Self time:   0.000292

count  total (s)   self (s)
   26              0.000259   return pumvisible() && !empty(v:completed_item) ? v:true : v:false

FUNCTION  <SNR>58_confirm()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/CompletionItem.vim:61
Called 1 time
Total time:   0.004447
 Self time:   0.000378

count  total (s)   self (s)
    1              0.000005   let l:suggest_position = a:args.suggest_position
    1              0.000004   let l:request_position = a:args.request_position
    1              0.000003   let l:current_position = a:args.current_position
    1              0.000003   let l:current_line = a:args.current_line
    1              0.000003   let l:completion_item = a:args.completion_item
    1              0.000009   let l:ExpandSnippet = get(a:args, 'expand_snippet', v:null)
                            
                              " 1. Prepare for alignment to VSCode behavior.
    1   0.000236   0.000049   let l:expansion = s:_get_expansion({   'suggest_position': l:suggest_position,   'request_position': l:request_position,   'current_position': l:current_position,   'current_line': l:current_line,   'completion_item': l:completion_item, })
    1              0.000005   if !empty(l:expansion)
                                " Remove commit characters if expansion is needed.
    1              0.000007     if getline('.') !=# l:current_line
                                  call setline(l:current_position.line + 1, l:current_line)
                                  call cursor(s:Position.lsp_to_vim('%', l:current_position))
    1              0.000001     endif
                            
                                " Restore state of the timing when `textDocument/completion` was sent.
    1   0.001924   0.000037     call s:TextEdit.apply('%', [{   'range': { 'start': l:request_position, 'end': l:current_position },   'newText': '' }])
    1              0.000001   endif
                            
                              " 2. Apply additionalTextEdits
    1              0.000010   if type(get(l:completion_item, 'additionalTextEdits', v:null)) == type([])
                                call s:TextEdit.apply('%', l:completion_item.additionalTextEdits)
    1              0.000001   endif
                            
                              " 3. Apply expansion
    1              0.000004   if !empty(l:expansion)
    1   0.000180   0.000019     let l:current_position = s:Position.cursor() " Update current_position to after additionalTextEdits.
    1              0.000038     let l:range = {   'start': extend({     'character': l:current_position.character - l:expansion.overflow_before,   }, l:current_position, 'keep'),   'end': extend({     'character': l:current_position.character + l:expansion.overflow_after,   }, l:current_position, 'keep') }
                            
                                " Snippet.
    1              0.000005     if l:expansion.is_snippet && !empty(l:ExpandSnippet)
                                  call s:TextEdit.apply('%', [{ 'range': l:range, 'newText': '' }])
                                  call cursor(s:Position.lsp_to_vim('%', l:range.start))
                                  call l:ExpandSnippet({ 'body': l:expansion.new_text, 'insert_text_mode': get(l:completion_item, 'insertTextMode', 2) })
                            
                                " TextEdit.
    1              0.000002     else
    1   0.001784   0.000032       call s:TextEdit.apply('%', [{ 'range': l:range, 'newText': l:expansion.new_text }])
                            
                                  " Move cursor position to end of new_text like as snippet.
    1   0.000037   0.000020       let l:lines = s:Text.split_by_eol(l:expansion.new_text)
    1              0.000008       let l:cursor = copy(l:range.start)
    1              0.000006       let l:cursor.line += len(l:lines) - 1
    1              0.000012       let l:cursor.character = strchars(l:lines[-1]) + (len(l:lines) == 1 ? l:cursor.character : 0)
    1   0.000086   0.000022       call cursor(s:Position.lsp_to_vim('%', l:cursor))
    1              0.000001     endif
    1              0.000001   endif

FUNCTION  <SNR>57_define()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Option.vim:13
Called 4 times
Total time:   0.000367
 Self time:   0.000367

count  total (s)   self (s)
    4              0.000028   let l:old = {}
    8              0.000058   for [l:key, l:value] in items(a:map)
    4              0.000060     let l:old[l:key] = eval(printf('&%s', l:key))
    4              0.000093     execute printf('let &%s = "%s"', l:key, l:value)
    8              0.000040   endfor
    4              0.000034   return { -> s:define(l:old) }

FUNCTION  <SNR>23_MRU_LoadList()
    Defined: ~/.local/share/nvim/plugged/mru/plugin/mru.vim:143
Called 1 time
Total time:   0.002412
 Self time:   0.000335

count  total (s)   self (s)
                              " If the MRU file is present, then load the list of filenames. Otherwise
                              " start with an empty list.
    1              0.000055   if filereadable(s:MRU_File)
    1              0.000182     let s:MRU_files = readfile(s:MRU_File)
    1              0.000033     if s:MRU_files[0] =~# '^\s*" Most recently edited files in Vim'
                                  " Generated by the previous version of the MRU plugin.
                                  " Discard the list.
                                  let s:MRU_files = []
    1              0.000011     elseif s:MRU_files[0] =~# '^#'
                                  " Remove the comment line
    1              0.000007       call remove(s:MRU_files, 0)
                                else
                                  " Unsupported format
                                  let s:MRU_files = []
    1              0.000001     endif
                              else
                                let s:MRU_files = []
    1              0.000001   endif
                            
                              " Refresh the MRU menu with the latest list of filenames
    1   0.002102   0.000025   call s:MRU_Refresh_Menu()

FUNCTION  vital#_compe#VS#Vim#Window#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Window.vim:7
Called 1 time
Total time:   0.000945
 Self time:   0.000398

count  total (s)   self (s)
    1   0.000944   0.000397 return map({'info': '', 'do': '', 'is_floating': '', 'find': '', 'scroll': '', 'screenpos': ''}, "vital#_compe#function('<SNR>50_' . v:key)")

FUNCTION  <SNR>54__fix_cursor_position()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:87
Called 2 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    2              0.000016   let l:lines_len = len(a:lines)
    2              0.000014   let l:range_len = (a:text_edit.range.end.line - a:text_edit.range.start.line) + 1
                            
    2              0.000009   if a:text_edit.range.end.line < a:position.line
                                let a:position.line += l:lines_len - l:range_len
    2              0.000014   elseif a:text_edit.range.end.line == a:position.line && a:text_edit.range.end.character <= a:position.character
    2              0.000010     let a:position.line += l:lines_len - l:range_len
    2              0.000020     let a:position.character = strchars(a:lines[-1]) + (a:position.character - a:text_edit.range.end.character)
    2              0.000005     if l:lines_len == 1
    2              0.000008       let a:position.character += a:text_edit.range.start.character
    2              0.000003     endif
    2              0.000002   endif

FUNCTION  <SNR>54__normalize()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:105
Called 2 times
Total time:   0.000681
 Self time:   0.000149

count  total (s)   self (s)
    2              0.000022   let l:text_edits = type(a:text_edits) == type([]) ? a:text_edits : [a:text_edits]
    2   0.000205   0.000034   let l:text_edits = s:_range(l:text_edits)
    2              0.000029   let l:text_edits = sort(l:text_edits, function('s:_compare'))
    2              0.000011   let l:text_edits = reverse(l:text_edits)
    2   0.000408   0.000047   return s:_fix_text_edits(a:bufnr, l:text_edits)

FUNCTION  <SNR>49_plugin_name()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:112
Called 7 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    7              0.000020   return self._plugin_name

FUNCTION  <SNR>29_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/plugin/matchparen.vim:40
Called 20 times
Total time:   0.088533
 Self time:   0.087972

count  total (s)   self (s)
                              " Remove any previous match.
   20   0.000831   0.000270   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   20              0.000147   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   20              0.000017   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   20              0.000114   let c_lnum = line('.')
   20              0.000081   let c_col = col('.')
   20              0.000037   let before = 0
                            
   20              0.000091   let text = getline(c_lnum)
   20              0.000534   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   20              0.000078   if empty(matches)
                                let [c_before, c] = ['', '']
   20              0.000025   else
   20              0.000143     let [c_before, c] = matches[1:2]
   20              0.000020   endif
   20              0.000664   let plist = split(&matchpairs, '.\zs[:,]')
   20              0.000163   let i = index(plist, c)
   20              0.000071   if i < 0
                                " not found, in Insert mode try character before the cursor
   20              0.000122     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   10              0.000044       let before = strlen(c_before)
   10              0.000022       let c = c_before
   10              0.000078       let i = index(plist, c)
   20              0.000021     endif
   20              0.000026     if i < 0
                                  " not found, nothing to do
   18              0.000029       return
    2              0.000002     endif
    2              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
    2              0.000004   if i % 2 == 0
    2              0.000005     let s_flags = 'nW'
    2              0.000007     let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
    2              0.000002   endif
    2              0.000005   if c == '['
                                let c = '\['
                                let c2 = '\]'
    2              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    2              0.000003   if before > 0
    2              0.000014     let has_getcurpos = exists("*getcurpos")
    2              0.000004     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    2              0.000011       let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
    2              0.000002     endif
    2              0.000012     call cursor(c_lnum, c_col - before)
    2              0.000002   endif
                            
    2              0.000018   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    2              0.000002   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
    2              0.000014     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    2              0.000004     try
    2              0.000424       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    2              0.000003     endtry
    2              0.000002   endif
                            
                              " Limit the search to lines visible in the window.
    2              0.000012   let stoplinebottom = line('w$')
    2              0.000008   let stoplinetop = line('w0')
    2              0.000004   if i % 2 == 0
    2              0.000005     let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
    2              0.000002   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    2              0.000009   if mode() == 'i' || mode() == 'R'
    2              0.000017     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    2              0.000002   endif
    2              0.000002   try
    2              0.083781     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    2              0.000003   endtry
                            
    2              0.000004   if before > 0
    2              0.000003     if has_getcurpos
    2              0.000013       call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
    2              0.000002     endif
    2              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    2              0.000006   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
    2              0.000002   endif

FUNCTION  <SNR>18_on_insert_leave()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/plugin/compe.vim:32
Called 1 time
Total time:   0.000800
 Self time:   0.000800

count  total (s)   self (s)
    1              0.000796   call luaeval('require"compe"._on_insert_leave()')

FUNCTION  <SNR>30_LocalBrowse()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/plugin/netrwPlugin.vim:102
Called 3 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    3              0.000011   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    3              0.000002   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    3              0.000014   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    3              0.000031   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    3              0.000002   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    3              0.000002   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  compe#confirmation#lsp()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/compe/confirmation.vim:8
Called 1 time
Total time:   0.009492
 Self time:   0.000214

count  total (s)   self (s)
    1              0.000007   let l:current_line = getline('.')
    1              0.000003   let l:completed_item = a:args.completed_item
    1              0.000002   let l:completion_item = a:args.completion_item
    1              0.000014   let l:suggest_position = { 'line': line('.') - 1, 'character': strchars(strpart(l:current_line, 0, l:completed_item.suggest_offset - 1)) }
    1   0.000100   0.000012   let l:current_position = s:Position.cursor()
    1              0.000003   let l:request_position = a:args.request_position
    1   0.004792   0.000069   let l:ExpandSnippet = compe#confirmation#get_expand_snippet()
    1              0.000006   if empty(l:ExpandSnippet)
                                let l:ExpandSnippet = function('s:simple_expand_snippet')
    1              0.000002   endif
    1   0.004552   0.000085   call s:CompletionItem.confirm({   'suggest_position': l:suggest_position,   'request_position': s:min(l:request_position, l:current_position),   'current_position': l:current_position,   'current_line': getline('.'),   'completion_item': l:completion_item,   'expand_snippet': l:ExpandSnippet, })

FUNCTION  <SNR>23_MRU_SaveList()
    Defined: ~/.local/share/nvim/plugged/mru/plugin/mru.vim:169
Called 1 time
Total time:   0.000444
 Self time:   0.000444

count  total (s)   self (s)
    1              0.000003   let l = []
    1              0.000005   call add(l, '# Most recently edited files in Vim (version 3.0)')
    1              0.000029   call extend(l, s:MRU_files)
    1              0.000406   call writefile(l, s:MRU_File)

FUNCTION  vital#compe#new()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:9
Called 2 times
Total time:   0.000092
 Self time:   0.000039

count  total (s)   self (s)
    2   0.000089   0.000037   return s:new(s:plugin_name)

FUNCTION  <SNR>54__substitute()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:46
Called 2 times
Total time:   0.002831
 Self time:   0.001282

count  total (s)   self (s)
    2              0.000003   try
                                " Save state.
    2   0.000236   0.000043     let l:Restore = s:Option.define({   'foldenable': '0', })
    2              0.000034     let l:view = winsaveview()
                            
                                " Apply substitute.
    2   0.000731   0.000051     let [l:fixeol, l:text_edits] = s:_normalize(a:bufnr, a:text_edits)
    4              0.000013     for l:text_edit in l:text_edits
    2   0.000196   0.000049       let l:start = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.start)
    2   0.000170   0.000041       let l:end = s:Position.lsp_to_vim(a:bufnr, l:text_edit.range.end)
    2   0.000074   0.000041       let l:text = s:Text.normalize_eol(l:text_edit.newText)
    2              0.000618       execute printf('noautocmd keeppatterns keepjumps silent %ssubstitute/\%%%sl\%%%sc\_.\{-}\%%%sl\%%%sc/\=l:text/%se',   l:start[0],   l:start[0],   l:start[1],   l:end[0],   l:end[1],   &gdefault ? 'g' : '' )
    2   0.000328   0.000166       call s:_fix_cursor_position(a:current_position, l:text_edit, s:Text.split_by_eol(l:text))
    4              0.000011     endfor
                            
                                " Remove last empty line if fixeol enabled.
    2              0.000009     if l:fixeol && getline('$') ==# ''
                                  noautocmd keeppatterns keepjumps silent $delete _
    2              0.000002     endif
                              catch /.*/
                                echomsg string({ 'exception': v:exception, 'throwpoint': v:throwpoint })
    2              0.000004   finally
                                " Restore state.
    2   0.000236   0.000033     call l:Restore()
    2              0.000018     call winrestview(l:view)
    2              0.000004   endtry

FUNCTION  <SNR>53_vim_to_lsp()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Position.vim:20
Called 4 times
Total time:   0.000364
 Self time:   0.000233

count  total (s)   self (s)
    4   0.000264   0.000133   let l:line = s:_get_buffer_line(a:expr, a:pos[0])
    4              0.000014   if l:line is v:null
                                return {   'line': a:pos[0] - 1,   'character': a:pos[1] - 1 }
    4              0.000005   endif
                            
    4              0.000053   return {   'line': a:pos[0] - 1,   'character': strchars(strpart(l:line, 0, a:pos[1] - 1)) }

FUNCTION  <SNR>18_on_complete_changed()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/plugin/compe.vim:18
Called 4 times
Total time:   0.000280
 Self time:   0.000246

count  total (s)   self (s)
    4   0.000276   0.000242   call luaeval('require"compe"._on_complete_changed()')

FUNCTION  <SNR>54__vital_loaded()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:13
Called 1 time
Total time:   0.004740
 Self time:   0.000068

count  total (s)   self (s)
    1   0.001526   0.000017   let s:Text = a:V.import('VS.LSP.Text')
    1   0.000098   0.000018   let s:Position = a:V.import('VS.LSP.Position')
    1   0.001728   0.000015   let s:Buffer = a:V.import('VS.Vim.Buffer')
    1   0.001384   0.000016   let s:Option = a:V.import('VS.Vim.Option')

FUNCTION  <SNR>23_MRU_escape_filename()
    Defined: ~/.local/share/nvim/plugged/mru/plugin/mru.vim:259
Called 22 times
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
   22              0.000101   if exists("*fnameescape")
   22              0.000125     return fnameescape(a:fname)
                              else
                                return escape(a:fname, s:esc_filename_chars)
                              endif

FUNCTION  <SNR>18_on_text_changed()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/plugin/compe.vim:39
Called 8 times
Total time:   0.015880
 Self time:   0.007161

count  total (s)   self (s)
    8   0.015868   0.007149   call luaeval('require"compe"._on_text_changed()')

FUNCTION  <SNR>49_new()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:22
Called 3 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    3              0.000050   let base = deepcopy(s:Vital)
    3              0.000014   let base._plugin_name = a:plugin_name
    3              0.000008   return base

FUNCTION  <SNR>58__trim_tabstop()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/CompletionItem.vim:175
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    1              0.000024   return substitute(a:text, '\%(\$0\|\${0}\)$', '', 'g')

FUNCTION  <SNR>29_Remove_Matches()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/plugin/matchparen.vim:197
Called 22 times
Total time:   0.000603
 Self time:   0.000603

count  total (s)   self (s)
   22              0.000204   if exists('w:paren_hl_on') && w:paren_hl_on
    1              0.000103     silent! call matchdelete(3)
    1              0.000011     let w:paren_hl_on = 0
   22              0.000072   endif

FUNCTION  <SNR>54_apply()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:30
Called 2 times
Total time:   0.003640
 Self time:   0.000279

count  total (s)   self (s)
    2              0.000016   let l:current_bufname = bufname('%')
    2   0.000251   0.000035   let l:current_position = s:Position.cursor()
                            
    2   0.000117   0.000042   let l:target_bufnr = s:_switch(a:path)
    2   0.002902   0.000072   call s:_substitute(l:target_bufnr, a:text_edits, l:current_position)
    2   0.000142   0.000041   let l:current_bufnr = s:_switch(l:current_bufname)
                            
    2              0.000007   if l:current_bufnr == l:target_bufnr
    2   0.000188   0.000048     call cursor(s:Position.lsp_to_vim('%', l:current_position))
    2              0.000002   endif

FUNCTION  <SNR>54__fix_text_edits()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/TextEdit.vim:147
Called 2 times
Total time:   0.000361
 Self time:   0.000336

count  total (s)   self (s)
    2   0.000114   0.000090   let l:max = s:Buffer.get_line_count(a:bufnr)
                            
    2              0.000008   let l:fixeol = v:false
    2              0.000006   let l:text_edits = []
    4              0.000013   for l:text_edit in a:text_edits
    2              0.000008     if l:max <= l:text_edit.range.start.line
                                  let l:text_edit.range.start.line = l:max - 1
                                  let l:text_edit.range.start.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:text_edit.newText = "\n" . l:text_edit.newText
                                  let l:fixeol = &fixendofline && !&binary
    2              0.000003     endif
    2              0.000007     if l:max <= l:text_edit.range.end.line
                                  let l:text_edit.range.end.line = l:max - 1
                                  let l:text_edit.range.end.character = strchars(get(getbufline(a:bufnr, '$'), 0, ''))
                                  let l:fixeol = &fixendofline && !&binary
    2              0.000003     endif
    2              0.000014     call add(l:text_edits, l:text_edit)
    4              0.000013   endfor
                            
    2              0.000010   return [l:fixeol, l:text_edits]

FUNCTION  <SNR>49__get_module()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:218
Called 7 times
Total time:   0.011766
 Self time:   0.002854

count  total (s)   self (s)
    7   0.000586   0.000291   let funcname = s:_import_func_name(self.plugin_name(), a:name)
    7              0.000012   try
    7   0.011063   0.002446     return call(funcname, [])
                              catch /^Vim\%((\a\+)\)\?:E117:/
                                return s:_get_builtin_module(a:name)
    7              0.000020   endtry

FUNCTION  vital#_compe#VS#LSP#Position#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Position.vim:7
Called 1 time
Total time:   0.000080
 Self time:   0.000056

count  total (s)   self (s)
    1   0.000079   0.000055 return map({'cursor': '', 'vim_to_lsp': '', 'lsp_to_vim': ''}, "vital#_compe#function('<SNR>53_' . v:key)")

FUNCTION  <SNR>49__import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:143
Called 11 times
Total time:   0.018240
 Self time:   0.004692

count  total (s)   self (s)
   11              0.000058   if has_key(s:loaded, a:name)
    4              0.000039     return copy(s:loaded[a:name])
    7              0.000007   endif
    7   0.011896   0.000129   let module = self._get_module(a:name)
    7              0.000041   if has_key(module, '_vital_created')
                                call module._vital_created(module)
    7              0.000009   endif
    7              0.000518   let export_module = filter(copy(module), 'v:key =~# "^\\a"')
                              " Cache module before calling module._vital_loaded() to avoid cyclic
                              " dependences but remove the cache if module._vital_loaded() fails.
                              " let s:loaded[a:name] = export_module
    7              0.000053   let s:loaded[a:name] = export_module
    7              0.000033   if has_key(module, '_vital_loaded')
    2              0.000005     try
    2   0.000304   0.000212       call module._vital_loaded(vital#{s:plugin_name}#new())
                                catch
                                  unlet s:loaded[a:name]
                                  throw 'vital: fail to call ._vital_loaded(): ' . v:exception . " from:\n" . s:_format_throwpoint(v:throwpoint)
    2              0.000003     endtry
    7              0.000006   endif
    7              0.000052   return copy(s:loaded[a:name])

FUNCTION  vital#_compe#function()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe.vim:7
Called 24 times
Total time:   0.000227
 Self time:   0.000227

count  total (s)   self (s)
   24              0.000204   silent! return function(a:funcname)

FUNCTION  vital#_compe#VS#Vim#Buffer#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/Vim/Buffer.vim:7
Called 1 time
Total time:   0.000228
 Self time:   0.000160

count  total (s)   self (s)
    1   0.000227   0.000159 return map({'get_line_count': '', 'do': '', 'create': '', 'pseudo': '', 'ensure': '', 'load': ''}, "vital#_compe#function('<SNR>56_' . v:key)")

FUNCTION  <SNR>58__vital_loaded()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/CompletionItem.vim:13
Called 1 time
Total time:   0.000281
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000142   0.000017   let s:Position = a:V.import('VS.LSP.Position')
    1   0.000074   0.000011   let s:TextEdit = a:V.import('VS.LSP.TextEdit')
    1   0.000064   0.000009   let s:Text = a:V.import('VS.LSP.Text')

FUNCTION  <SNR>53__get_buffer_line()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Position.vim:49
Called 11 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
   11              0.000020   try
   11              0.000063     let l:expr = bufnr(a:expr)
                              catch /.*/
                                let l:expr = a:expr
   11              0.000017   endtry
   11              0.000043   if bufloaded(l:expr)
   11              0.000121     return get(getbufline(l:expr, a:lnum), 0, v:null)
                              elseif filereadable(a:expr)
                                return get(readfile(a:expr, '', a:lnum), 0, v:null)
                              endif
                              return v:null

FUNCTION  <SNR>6_LoadIndent()
    Defined: /usr/local/Cellar/neovim/HEAD-a03ffe1_2/share/nvim/runtime/indent.vim:13
Called 1 time
Total time:   0.001434
 Self time:   0.001311

count  total (s)   self (s)
    1              0.000005     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    1              0.000001     endif
    1              0.000006     let s = expand("<amatch>")
    1              0.000002     if s != ""
    1              0.000002       if exists("b:did_indent")
                            	unlet b:did_indent
    1              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    2              0.000010       for name in split(s, '\.')
    1   0.000960   0.000837         exe 'runtime! indent/' . name . '.vim'
    1              0.000432         exe 'runtime! indent/' . name . '.lua'
    2              0.000003       endfor
    1              0.000001     endif

FUNCTION  <SNR>49__dot_to_sharp()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:269
Called 7 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    7              0.000114   return substitute(a:name, '\.', '#', 'g')

FUNCTION  vital#compe#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/compe.vim:13
Called 4 times
Total time:   0.014454
 Self time:   0.000211

count  total (s)   self (s)
    4              0.000028   if !exists('s:V')
    1   0.000046   0.000020     let s:V = s:new(s:plugin_name)
    4              0.000006   endif
    4   0.014347   0.000131   return call(s:V.import, a:000, s:V)

FUNCTION  vital#_compe#VS#LSP#Text#import()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Text.vim:7
Called 1 time
Total time:   0.000175
 Self time:   0.000150

count  total (s)   self (s)
    1   0.000174   0.000149 return map({'normalize_eol': '', 'split_by_eol': ''}, "vital#_compe#function('<SNR>55_' . v:key)")

FUNCTION  <SNR>53_cursor()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Position.vim:13
Called 4 times
Total time:   0.000465
 Self time:   0.000101

count  total (s)   self (s)
    4   0.000461   0.000097   return s:vim_to_lsp('%', getpos('.')[1 : 3])

FUNCTION  <SNR>55_normalize_eol()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Text.vim:13
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000030   return substitute(a:text, "\r\n\\|\r", "\n", 'g')

FUNCTION  <SNR>55_split_by_eol()
    Defined: ~/.local/share/nvim/plugged/nvim-compe/autoload/vital/_compe/VS/LSP/Text.vim:20
Called 3 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    3              0.000055   return split(a:text, "\r\n\\|\r\\|\n", v:true)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   20   0.088533   0.087972  <SNR>29_Highlight_Matching_Pair()
    1   0.019392   0.003494  <SNR>8_SynSet()
   11   0.019132   0.000794  <SNR>49_import()
   11   0.018240   0.004692  <SNR>49__import()
    8   0.015880   0.007161  <SNR>18_on_text_changed()
    4   0.014454   0.000211  vital#compe#import()
    7   0.011766   0.002854  <SNR>49__get_module()
    1   0.009492   0.000214  compe#confirmation#lsp()
    1   0.008621   0.008218  <SNR>5_LoadFTPlugin()
    3   0.005915   0.000955  <SNR>23_MRU_AddFile()
    1   0.004740   0.000068  <SNR>54__vital_loaded()
    1   0.004724             compe#confirmation#get_expand_snippet()
    1   0.004447   0.000378  <SNR>58_confirm()
    2   0.004181   0.000594  <SNR>23_MRU_Refresh_Menu()
    2   0.003640   0.000279  <SNR>54_apply()
    2   0.003551   0.003337  <SNR>23_MRU_add_files_to_menu()
    1   0.002942             <SNR>18_on_insert_enter()
    2   0.002831   0.001282  <SNR>54__substitute()
    1   0.002412   0.000335  <SNR>23_MRU_LoadList()
    1   0.001434   0.001311  <SNR>6_LoadIndent()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   20   0.088533   0.087972  <SNR>29_Highlight_Matching_Pair()
    1   0.008621   0.008218  <SNR>5_LoadFTPlugin()
    8   0.015880   0.007161  <SNR>18_on_text_changed()
    1              0.004724  compe#confirmation#get_expand_snippet()
   11   0.018240   0.004692  <SNR>49__import()
    1   0.019392   0.003494  <SNR>8_SynSet()
    2   0.003551   0.003337  <SNR>23_MRU_add_files_to_menu()
    1              0.002942  <SNR>18_on_insert_enter()
    7   0.011766   0.002854  <SNR>49__get_module()
    1   0.001434   0.001311  <SNR>6_LoadIndent()
    2   0.002831   0.001282  <SNR>54__substitute()
    3   0.005915   0.000955  <SNR>23_MRU_AddFile()
    1              0.000800  <SNR>18_on_insert_leave()
   11   0.019132   0.000794  <SNR>49_import()
    1   0.000652   0.000634  compe#confirm()
   22              0.000603  <SNR>29_Remove_Matches()
    2   0.004181   0.000594  <SNR>23_MRU_Refresh_Menu()
    1              0.000444  <SNR>23_MRU_SaveList()
    1   0.000945   0.000398  vital#_compe#VS#Vim#Window#import()
    1   0.004447   0.000378  <SNR>58_confirm()

